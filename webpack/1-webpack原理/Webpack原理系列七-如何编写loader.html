<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Webpack 原理系列七：如何编写loader | duangdong的engineering</title>
    <meta name="generator" content="VuePress 1.9.10">
    <link rel="icon" href="/logo.png">
    <link rel="manifest" href="/manifest.json">
    <script>
  var _hmt = _hmt || [];
  (function() {
    var hm = document.createElement("script");
    hm.src = "https://hm.baidu.com/hm.js?0088ce24040b03f2947322ab31d23414";
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(hm, s);
  })();
  </script>
    <script>
  var _hmt = _hmt || [];
  _hmt.push(['_requirePlugin', 'UrlChangeTracker', {
    shouldTrackUrlChange: function (newPath, oldPath) {
      newPath = newPath.split('#')[0];
      oldPath = oldPath.split('#')[0];
      return newPath != oldPath;
    }}
  ]);
  </script>
    <meta name="description" content="前端相关知识归纳总结">
    <meta name="keywords" content="qd-blog,node,vuepress,leetcode,algorithm">
    
    <link rel="preload" href="/assets/css/0.styles.b4a844ec.css" as="style"><link rel="preload" href="/assets/js/app.04fd048c.js" as="script"><link rel="preload" href="/assets/js/2.57da4f88.js" as="script"><link rel="preload" href="/assets/js/1.a76cc220.js" as="script"><link rel="preload" href="/assets/js/49.3039c755.js" as="script"><link rel="prefetch" href="/assets/js/10.50f73657.js"><link rel="prefetch" href="/assets/js/11.0390ceee.js"><link rel="prefetch" href="/assets/js/12.f88bec36.js"><link rel="prefetch" href="/assets/js/13.963ad03b.js"><link rel="prefetch" href="/assets/js/14.512f15b9.js"><link rel="prefetch" href="/assets/js/15.a674496c.js"><link rel="prefetch" href="/assets/js/16.ed7e507f.js"><link rel="prefetch" href="/assets/js/17.de667ca5.js"><link rel="prefetch" href="/assets/js/18.b44e84af.js"><link rel="prefetch" href="/assets/js/19.5b5ad6a1.js"><link rel="prefetch" href="/assets/js/20.6800493a.js"><link rel="prefetch" href="/assets/js/21.6589052c.js"><link rel="prefetch" href="/assets/js/22.f648d829.js"><link rel="prefetch" href="/assets/js/23.d80486b4.js"><link rel="prefetch" href="/assets/js/24.d1ded971.js"><link rel="prefetch" href="/assets/js/25.2b5651f2.js"><link rel="prefetch" href="/assets/js/26.be0532f1.js"><link rel="prefetch" href="/assets/js/27.601e9758.js"><link rel="prefetch" href="/assets/js/28.5f3c5013.js"><link rel="prefetch" href="/assets/js/29.b11be3d0.js"><link rel="prefetch" href="/assets/js/3.13e892f5.js"><link rel="prefetch" href="/assets/js/30.b5a85a3d.js"><link rel="prefetch" href="/assets/js/31.656e3cca.js"><link rel="prefetch" href="/assets/js/32.df47284c.js"><link rel="prefetch" href="/assets/js/33.cf2bef7f.js"><link rel="prefetch" href="/assets/js/34.b76a28cc.js"><link rel="prefetch" href="/assets/js/35.4656aa60.js"><link rel="prefetch" href="/assets/js/36.bc0d7be9.js"><link rel="prefetch" href="/assets/js/37.41e22cc1.js"><link rel="prefetch" href="/assets/js/38.9a20d42b.js"><link rel="prefetch" href="/assets/js/39.5d96398a.js"><link rel="prefetch" href="/assets/js/4.5bdb9365.js"><link rel="prefetch" href="/assets/js/40.fb9028aa.js"><link rel="prefetch" href="/assets/js/41.96d148c1.js"><link rel="prefetch" href="/assets/js/42.26c75454.js"><link rel="prefetch" href="/assets/js/43.59ed847d.js"><link rel="prefetch" href="/assets/js/44.4c9bed25.js"><link rel="prefetch" href="/assets/js/45.547c992f.js"><link rel="prefetch" href="/assets/js/46.d63785ae.js"><link rel="prefetch" href="/assets/js/47.34a532a7.js"><link rel="prefetch" href="/assets/js/48.81fda019.js"><link rel="prefetch" href="/assets/js/5.7c68fdb5.js"><link rel="prefetch" href="/assets/js/50.bd461786.js"><link rel="prefetch" href="/assets/js/51.b83fa154.js"><link rel="prefetch" href="/assets/js/52.6880a119.js"><link rel="prefetch" href="/assets/js/53.f60e17c7.js"><link rel="prefetch" href="/assets/js/54.833a4f5c.js"><link rel="prefetch" href="/assets/js/55.ed6a7c66.js"><link rel="prefetch" href="/assets/js/56.c9eef7e1.js"><link rel="prefetch" href="/assets/js/57.abbfb924.js"><link rel="prefetch" href="/assets/js/58.c1df5fda.js"><link rel="prefetch" href="/assets/js/59.1615eb2d.js"><link rel="prefetch" href="/assets/js/6.c8da7ca7.js"><link rel="prefetch" href="/assets/js/60.a1480688.js"><link rel="prefetch" href="/assets/js/61.901ae4d3.js"><link rel="prefetch" href="/assets/js/62.dc705c01.js"><link rel="prefetch" href="/assets/js/63.a3367f7e.js"><link rel="prefetch" href="/assets/js/64.44397e2a.js"><link rel="prefetch" href="/assets/js/65.b6f8a966.js"><link rel="prefetch" href="/assets/js/66.305bd539.js"><link rel="prefetch" href="/assets/js/67.b47bf615.js"><link rel="prefetch" href="/assets/js/68.63565465.js"><link rel="prefetch" href="/assets/js/69.141e956c.js"><link rel="prefetch" href="/assets/js/7.e4c88d0e.js"><link rel="prefetch" href="/assets/js/vendors~docsearch.5143d2e0.js">
    <link rel="stylesheet" href="/assets/css/0.styles.b4a844ec.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">duangdong的engineering</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/engineering/" class="nav-link">
  工程化
</a></div><div class="nav-item"><a href="/webpack/" class="nav-link router-link-active">
  Webpack
</a></div><div class="nav-item"><a href="/webpack-explain/" class="nav-link">
  深入浅出Webpack
</a></div><div class="nav-item"><a href="/babel/" class="nav-link">
  Babel
</a></div><div class="nav-item"><a href="/micro-front/" class="nav-link">
  微前端
</a></div><div class="nav-item"><a href="https://link.aduang.cn" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Home
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/engineering/" class="nav-link">
  工程化
</a></div><div class="nav-item"><a href="/webpack/" class="nav-link router-link-active">
  Webpack
</a></div><div class="nav-item"><a href="/webpack-explain/" class="nav-link">
  深入浅出Webpack
</a></div><div class="nav-item"><a href="/babel/" class="nav-link">
  Babel
</a></div><div class="nav-item"><a href="/micro-front/" class="nav-link">
  微前端
</a></div><div class="nav-item"><a href="https://link.aduang.cn" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Home
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/webpack/" aria-current="page" class="sidebar-link">前端工程化</a></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>1-webpack原理</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/webpack/1-webpack原理/Webpack下的HMR机制原理.html" class="sidebar-link">Webpack 下的 HMR 机制原理: 120 行代码帮你搞定</a></li><li><a href="/webpack/1-webpack原理/Webpack原理系列一-一文吃透Webpack核心原理.html" class="sidebar-link">一文吃透 Webpack 核心原理</a></li><li><a href="/webpack/1-webpack原理/Webpack原理系列七-如何编写loader.html" class="active sidebar-link">Webpack 原理系列七：如何编写loader</a></li><li><a href="/webpack/1-webpack原理/Webpack原理系列九-Tree-Shaking实现原理.html" class="sidebar-link">Webpack 原理系列九：Tree-Shaking实现原理</a></li><li><a href="/webpack/1-webpack原理/Webpack原理系列二-Webpack插件架构深度讲解.html" class="sidebar-link">Webpack 插件架构深度讲解</a></li><li><a href="/webpack/1-webpack原理/Webpack原理系列五-Webpack-Chunk分包规则详解.html" class="sidebar-link">有点难的知识点： Webpack Chunk 分包规则详解</a></li><li><a href="/webpack/1-webpack原理/Webpack原理系列八-产物转译打包逻辑.html" class="sidebar-link">Webpack 原理系列八：产物转译打包逻辑</a></li><li><a href="/webpack/1-webpack原理/Webpack原理系列六-彻底理解Webpack运行时.html" class="sidebar-link">Webpack 原理系列六： 彻底理解Webpack运行时</a></li><li><a href="/webpack/1-webpack原理/Webpack原理系列四-Dependency-Graph深度解析.html" class="sidebar-link">有点难的 webpack 知识点：Dependency Graph 深度解析</a></li><li><a href="/webpack/1-webpack原理/webpack原理系列-使用 Cache 提升构建性能.html" class="sidebar-link">Webpack 性能系列一: 使用 Cache 提升构建性能</a></li><li><a href="/webpack/1-webpack原理/webpack方方面面的核心原理总结.html" class="sidebar-link">webpack 方方面面的核心原理总结</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>2-webpack优化</span> <span class="arrow right"></span></p> <!----></section></li><li><a href="/webpack/Koa2中使用webpack进行打包压缩.html" class="sidebar-link">Koa2中使用webpack进行打包压缩</a></li><li><a href="/webpack/esbuild为什么这么快.html" class="sidebar-link">esbuild 为什么这么快?</a></li><li><a href="/webpack/module-issuer属性详解.html" class="sidebar-link">十分钟精进 Webpack：module.issuer 属性详解</a></li><li><a href="/webpack/webpack-node.html" class="sidebar-link">Node中使用webpack打包时出现的错误和警告</a></li><li><a href="/webpack/不要再看loader原理了，自己写一个就什么都明白了.html" class="sidebar-link">不要再看loader原理了，自己写一个就什么都明白了</a></li><li><a href="/webpack/分享几个Webpack实用分析工具.html" class="sidebar-link">分享几个 Webpack 实用分析工具</a></li><li><a href="/webpack/如何开发VSCode-LSP服务.html" class="sidebar-link">实例解析：如何开发 VSCode LSP 服务</a></li><li><a href="/webpack/如何调试Webpack问题.html" class="sidebar-link">我是如何调试 Webpack 问题的</a></li><li><a href="/webpack/手把手带你入门Webpack-Plugin.html" class="sidebar-link">手把手带你入门 Webpack Plugin</a></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="webpack-原理系列七-如何编写loader"><a href="#webpack-原理系列七-如何编写loader" class="header-anchor">#</a> Webpack 原理系列七：如何编写loader</h1> <p>关于 Webpack Loader，网上已经有很多很多的资料，很难讲出花来，但是要写 Webpack 的系列博文又没办法绕开这一点，所以我阅读了超过 20 个开源项目，尽量全面地总结了一些编写 Loader 时需要了解的知识和技巧。包含：</p> <p><img src="https://mmbiz.qpic.cn/mmbiz_png/3xDuJ3eicibll65ExluHjiagfEzNZxz4BjzR9QRkibqRD4E95upPjeLWibLkXGPD8k2ydOq6Ibccibn7ViaoegJrjQgQQ/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p> <p>那么，我们开始吧。</p> <h1 id="认识-loader"><a href="#认识-loader" class="header-anchor">#</a> 认识 Loader</h1> <blockquote><p>❝</p> <p>如果要做总结的话，我认为 Loader 是一个带有副作用的内容转译器！</p> <p>❞</p></blockquote> <p>Webpack Loader 最核心的只能是实现内容转换器 —— 将各式各样的资源转化为标准 JavaScript 内容格式，例如：</p> <ul><li><code>css-loader</code> 将 css 转换为 <code>__WEBPACK_DEFAULT_EXPORT__ = &quot;.a{ xxx }&quot;</code> 格式</li> <li><code>html-loader</code> 将 html 转换为 <code>__WEBPACK_DEFAULT_EXPORT__ = &quot;&lt;!DOCTYPE xxx&quot;</code> 格式</li> <li><code>vue-loader</code> 更复杂一些，会将 <code>.vue</code> 文件转化为多个 JavaScript 函数，分别对应 template、js、css、custom block</li></ul> <p>那么为什么需要做这种转换呢？本质上是因为 Webpack 只认识符合 JavaScript 规范的文本(Webpack 5之后增加了其它 parser)：在构建(make)阶段，解析模块内容时会调用 <code>acorn</code>将文本转换为 AST 对象，进而分析代码结构，分析模块依赖；这一套逻辑对图片、json、Vue SFC等场景就不 work 了，就需要 Loader 介入将资源转化成 Webpack 可以理解的内容形态。</p> <blockquote><p>Plugin 是 Webpack 另一套扩展机制，功能更强，能够在各个对象的钩子中插入特化处理逻辑，它可以覆盖 Webpack 全生命流程，能力、灵活性、复杂度都会比 Loader 强很多，我们下次再讲。</p></blockquote> <h2 id="loader-基础"><a href="#loader-基础" class="header-anchor">#</a> Loader 基础</h2> <p>代码层面，Loader 通常是一个函数，结构如下：</p> <div class="language- extra-class"><pre class="language-text"><code>module.exports = function(source, sourceMap?, data?) {
  // source 为 loader 的输入，可能是文件内容，也可能是上一个 loader 处理结果
  return source;
};
</code></pre></div><p>Loader 函数接收三个参数，分别为：</p> <ul><li><code>source</code>：资源输入，对于第一个执行的 loader 为资源文件的内容；后续执行的 loader 则为前一个 loader 的执行结果</li> <li><code>sourceMap</code>: 可选参数，代码的 sourcemap 结构</li> <li><code>data</code>: 可选参数，其它需要在 Loader 链中传递的信息，比如 posthtml/posthtml-loader 就会通过这个参数传递参数的 AST 对象</li></ul> <p>其中 <code>source</code> 是最重要的参数，大多数 Loader 要做的事情就是将 <code>source</code> 转译为另一种形式的 <code>output</code> ，比如 webpack-contrib/raw-loader 的核心源码：</p> <div class="language- extra-class"><pre class="language-text"><code>//... 
export default function rawLoader(source) {
  // ...

  const json = JSON.stringify(source)
    .replace(/\u2028/g, '\\u2028')
    .replace(/\u2029/g, '\\u2029');

  const esModule =
    typeof options.esModule !== 'undefined' ? options.esModule : true;

  return `${esModule ? 'export default' : 'module.exports ='} ${json};`;
}
</code></pre></div><p>这段代码的作用是将文本内容包裹成 JavaScript 模块，例如：</p> <div class="language- extra-class"><pre class="language-text"><code>// source
I am Tecvan

// output
module.exports = &quot;I am Tecvan&quot;
</code></pre></div><p>经过模块化包装之后，这段文本内容转身变成 Webpack 可以处理的资源模块，其它 module 也就能引用、使用它了。</p> <h2 id="返回多个结果"><a href="#返回多个结果" class="header-anchor">#</a> 返回多个结果</h2> <p>上例通过 <code>return</code> 语句返回处理结果，除此之外 Loader 还可以以 <code>callback</code> 方式返回更多信息，供下游 Loader 或者 Webpack 本身使用，例如在 webpack-contrib/eslint-loader 中：</p> <div class="language- extra-class"><pre class="language-text"><code>export default function loader(content, map) {
  // ...
  linter.printOutput(linter.lint(content));
  this.callback(null, content, map);
}
</code></pre></div><p>通过 <code>this.callback(null, content, map)</code> 语句同时返回转译后的内容与 sourcemap 内容。<code>callback</code> 的完整签名如下：</p> <div class="language- extra-class"><pre class="language-text"><code>this.callback(
    // 异常信息，Loader 正常运行时传递 null 值即可
    err: Error | null,
    // 转译结果
    content: string | Buffer,
    // 源码的 sourcemap 信息
    sourceMap?: SourceMap,
    // 任意需要在 Loader 间传递的值
    // 经常用来传递 ast 对象，避免重复解析
    data?: any
);
</code></pre></div><h2 id="异步处理"><a href="#异步处理" class="header-anchor">#</a> 异步处理</h2> <p>涉及到异步或 CPU 密集操作时，Loader 中还可以以异步形式返回处理结果，例如 webpack-contrib/less-loader 的核心逻辑：</p> <div class="language- extra-class"><pre class="language-text"><code>import less from &quot;less&quot;;

async function lessLoader(source) {
  // 1. 获取异步回调函数
  const callback = this.async();
  // ...

  let result;

  try {
    // 2. 调用less 将模块内容转译为 css
    result = await (options.implementation || less).render(data, lessOptions);
  } catch (error) {
    // ...
  }

  const { css, imports } = result;

  // ...

  // 3. 转译结束，返回结果
  callback(null, css, map);
}

export default lessLoader;
</code></pre></div><p>在 less-loader 中，逻辑分三步：</p> <ul><li>调用 <code>this.async</code> 获取异步回调函数，此时 Webpack 会将该 Loader 标记为异步加载器，会挂起当前执行队列直到 <code>callback</code> 被触发</li> <li>调用 <code>less</code> 库将 less 资源转译为标准 css</li> <li>调用异步回调 <code>callback</code> 返回处理结果</li></ul> <p><code>this.async</code> 返回的异步回调函数签名与上一节介绍的 <code>this.callback</code> 相同，此处不再赘述。</p> <h2 id="缓存"><a href="#缓存" class="header-anchor">#</a> 缓存</h2> <p>Loader 为开发者提供了一种便捷的扩展方法，但在 Loader 中执行的各种资源内容转译操作通常都是 CPU 密集型 —— 这放在单线程的 Node 场景下可能导致性能问题；又或者异步 Loader 会挂起后续的加载器队列直到异步 Loader 触发回调，稍微不注意就可能导致整个加载器链条的执行时间过长。</p> <p>为此，默认情况下 Webpack 会缓存 Loader 的执行结果直到资源或资源依赖发生变化，开发者需要对此有个基本的理解，必要时可以通过 <code>this.cachable</code> 显式声明不作缓存，例如：</p> <div class="language- extra-class"><pre class="language-text"><code>module.exports = function(source) {
  this.cacheable(false);
  // ...
  return output;
};
</code></pre></div><h2 id="上下文与-side-effect"><a href="#上下文与-side-effect" class="header-anchor">#</a> 上下文与 Side Effect</h2> <p>除了作为内容转换器外，Loader 运行过程还可以通过一些上下文接口，有限制地影响 Webpack 编译过程，从而产生内容转换之外的副作用。</p> <p>上下文信息可通过 <code>this</code> 获取，<code>this</code> 对象由 <code>NormolModule.createLoaderContext</code> 函数在调用 Loader 前创建，常用的接口包括：</p> <div class="language- extra-class"><pre class="language-text"><code>const loaderContext = {
    // 获取当前 Loader 的配置信息
    getOptions: schema =&gt; {},
    // 添加警告
    emitWarning: warning =&gt; {},
    // 添加错误信息，注意这不会中断 Webpack 运行
    emitError: error =&gt; {},
    // 解析资源文件的具体路径
    resolve(context, request, callback) {},
    // 直接提交文件，提交的文件不会经过后续的chunk、module处理，直接输出到 fs
    emitFile: (name, content, sourceMap, assetInfo) =&gt; {},
    // 添加额外的依赖文件
    // watch 模式下，依赖文件发生变化时会触发资源重新编译
    addDependency(dep) {},
};
</code></pre></div><p>其中，<code>addDependency</code>、<code>emitFile</code> 、<code>emitError</code>、<code>emitWarning</code> 都会对后续编译流程产生副作用，例如 <code>less-loader</code> 中包含这样一段代码：</p> <div class="language- extra-class"><pre class="language-text"><code>  try {
    result = await (options.implementation || less).render(data, lessOptions);
  } catch (error) {
    // ...
  }

  const { css, imports } = result;

  imports.forEach((item) =&gt; {
    // ...
    this.addDependency(path.normalize(item));
  });
</code></pre></div><p>解释一下，代码中首先调用 <code>less</code> 编译文件内容，之后遍历所有 <code>import</code> 语句，也就是上例 <code>result.imports</code> 数组，一一调用 <code>this.addDependency</code> 函数将 import 到的其它资源都注册为依赖，之后这些其它资源文件发生变化时都会触发重新编译。</p> <h1 id="loader-链式调用"><a href="#loader-链式调用" class="header-anchor">#</a> Loader 链式调用</h1> <p>使用上，可以为某种资源文件配置多个 Loader，Loader 之间按照配置的顺序从前到后(pitch)，再从后到前依次执行，从而形成一套内容转译工作流，例如对于下面的配置：</p> <div class="language- extra-class"><pre class="language-text"><code>module.exports = {
  module: {
    rules: [
      {
        test: /\.less$/i,
        use: [
          &quot;style-loader&quot;,
          &quot;css-loader&quot;,
          &quot;less-loader&quot;,
        ],
      },
    ],
  },
};
</code></pre></div><p>这是一个典型的 less 处理场景，针对 <code>.less</code> 后缀的文件设定了：less、css、style 三个 loader 协作处理资源文件，按照定义的顺序，Webpack 解析 less 文件内容后先传入 less-loader；less-loader 返回的结果再传入 css-loader 处理；css-loader 的结果再传入 style-loader；最终以 style-loader 的处理结果为准，流程简化后如：</p> <p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="图片"></p> <p>上述示例中，三个 Loader 分别起如下作用：</p> <ul><li><code>less-loader</code>：实现 less =&gt; css 的转换，输出 css 内容，无法被直接应用在 Webpack 体系下</li> <li><code>css-loader</code>：将 css 内容包装成类似 <code>module.exports = &quot;${css}&quot;</code> 的内容，包装后的内容符合 JavaScript 语法</li> <li><code>style-loader</code>：做的事情非常简单，就是将 css 模块包进 require 语句，并在运行时调用 injectStyle 等函数将内容注入到页面的 style 标签</li></ul> <p>三个 Loader 分别完成内容转化工作的一部分，形成从右到左的调用链条。链式调用这种设计有两个好处，一是保持单个 Loader 的单一职责，一定程度上降低代码的复杂度；二是细粒度的功能能够被组装成复杂而灵活的处理链条，提升单个 Loader 的可复用性。</p> <p>不过，这只是链式调用的一部分，这里面有两个问题：</p> <ul><li>Loader 链条一旦启动之后，需要所有 Loader 都执行完毕才会结束，没有中断的机会 —— 除非显式抛出异常</li> <li>某些场景下并不需要关心资源的具体内容，但 Loader 需要在 source 内容被读取出来之后才会执行</li></ul> <p>为了解决这两个问题，Webpack 在 loader 基础上叠加了 <code>pitch</code> 的概念。</p> <h1 id="loader-pitch"><a href="#loader-pitch" class="header-anchor">#</a> Loader Pitch</h1> <p>网络上关于 Loader 的文章已经有非常非常多，但多数并没有对 <code>pitch</code> 这一重要特性做足够深入的介绍，没有讲清楚为什么要设计 pitch 这个功能，pitch 有哪些常见用例等。</p> <p>在这一节，我会从 what、how、why 三个维度展开聊聊 loader pitch 这一特性。</p> <h2 id="什么是-pitch"><a href="#什么是-pitch" class="header-anchor">#</a> 什么是 pitch</h2> <p>Webpack 允许在这个函数上挂载名为 <code>pitch</code> 的函数，运行时 pitch 会比 Loader 本身更早执行，例如：</p> <div class="language- extra-class"><pre class="language-text"><code>const loader = function (source){
    console.log('后执行')
    return source;
}

loader.pitch = function(requestString) {
    console.log('先执行')
}

module.exports = loader
</code></pre></div><p>Pitch 函数的完整签名：</p> <div class="language- extra-class"><pre class="language-text"><code>function pitch(
    remainingRequest: string, previousRequest: string, data = {}
): void {
}
</code></pre></div><p>包含三个参数：</p> <ul><li><code>remainingRequest</code> : 当前 loader 之后的资源请求字符串</li> <li><code>previousRequest</code> : 在执行当前 loader 之前经历过的 loader 列表</li> <li><code>data</code> : 与 Loader 函数的 <code>data</code> 相同，用于传递需要在 Loader 传播的信息</li></ul> <p>这些参数不复杂，但与 requestString 紧密相关，我们看个例子加深了解：</p> <div class="language- extra-class"><pre class="language-text"><code>module.exports = {
  module: {
    rules: [
      {
        test: /\.less$/i,
        use: [
          &quot;style-loader&quot;, &quot;css-loader&quot;, &quot;less-loader&quot;
        ],
      },
    ],
  },
};
</code></pre></div><p><code>css-loader.pitch</code> 中拿到的参数依次为：</p> <div class="language- extra-class"><pre class="language-text"><code>// css-loader 之后的 loader 列表及资源路径
remainingRequest = less-loader!./xxx.less
// css-loader 之前的 loader 列表
previousRequest = style-loader
// 默认值
data = {}
</code></pre></div><h2 id="调度逻辑"><a href="#调度逻辑" class="header-anchor">#</a> 调度逻辑</h2> <p>Pitch 翻译成中文是<strong>抛、球场、力度、事物最高点</strong>等，我觉得 pitch 特性之所以被忽略完全是这个名字的锅，它背后折射的是一整套 Loader 被执行的生命周期概念。</p> <p>实现上，Loader 链条执行过程分三个阶段：pitch、解析资源、执行，设计上与 DOM 的事件模型非常相似，pitch 对应到捕获阶段；执行对应到冒泡阶段；而两个阶段之间 Webpack 会执行资源内容的读取、解析操作，对应 DOM 事件模型的 AT_TARGET 阶段：</p> <p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="图片"></p> <p><code>pitch</code> 阶段按配置顺序从左到右逐个执行 <code>loader.pitch</code> 函数(如果有的话)，开发者可以在 <code>pitch</code> 返回任意值中断后续的链路的执行：</p> <p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="图片"></p> <p>那么为什么要设计 pitch 这一特性呢？在分析了 style-loader、vue-loader、to-string-loader 等开源项目之后，我个人总结出两个字：<strong>「阻断」</strong>！</p> <h2 id="示例-style-loader"><a href="#示例-style-loader" class="header-anchor">#</a> 示例：style-loader</h2> <p>先回顾一下前面提到过的 less 加载链条：</p> <ul><li><code>less-loader</code> ：将 less 规格的内容转换为标准 css</li> <li><code>css-loader</code> ：将 css 内容包裹为 JavaScript 模块</li> <li><code>style-loader</code> ：将 JavaScript 模块的导出结果以 <code>link</code> 、<code>style</code> 标签等方式挂载到 html 中，让 css 代码能够正确运行在浏览器上</li></ul> <p>实际上， <code>style-loader</code> 只是负责让 css 能够在浏览器环境下跑起来，本质上并不需要关心具体内容，很适合用 pitch 来处理，核心代码：</p> <div class="language- extra-class"><pre class="language-text"><code>// ...
// Loader 本身不作任何处理
const loaderApi = () =&gt; {};

// pitch 中根据参数拼接模块代码
loaderApi.pitch = function loader(remainingRequest) {
  //...

  switch (injectType) {
    case 'linkTag': {
      return `${
        esModule
          ? `...`
          // 引入 runtime 模块
          : `var api = require(${loaderUtils.stringifyRequest(
              this,
              `!${path.join(__dirname, 'runtime/injectStylesIntoLinkTag.js')}`
            )});
            // 引入 css 模块
            var content = require(${loaderUtils.stringifyRequest(
              this,
              `!!${remainingRequest}`
            )});

            content = content.__esModule ? content.default : content;`
      } // ...`;
    }

    case 'lazyStyleTag':
    case 'lazySingletonStyleTag': {
        //...
    }

    case 'styleTag':
    case 'singletonStyleTag':
    default: {
        // ...
    }
  }
};

export default loaderApi;
</code></pre></div><p>关键点：</p> <ul><li><p><code>loaderApi</code> 为空函数，不做任何处理</p></li> <li><p><code>loaderApi.pitch</code> 中拼接结果，导出的代码包含：</p></li> <li><ul><li>引入运行时模块 <code>runtime/injectStylesIntoLinkTag.js</code></li> <li>复用 <code>remainingRequest</code> 参数，重新引入 css 文件</li></ul></li></ul> <p>运行结果大致如：</p> <div class="language- extra-class"><pre class="language-text"><code>var api = require('xxx/style-loader/lib/runtime/injectStylesIntoLinkTag.js')
var content = require('!!css-loader!less-loader!./xxx.less');
</code></pre></div><p>注意了，到这里 style-loader 的 pitch 函数返回这一段内容，后续的 Loader 就不会继续执行，当前调用链条中断了：</p> <p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="图片"></p> <p>之后，Webpack 继续解析、构建 style-loader 返回的结果，遇到 inline loader 语句：</p> <div class="language- extra-class"><pre class="language-text"><code>var content = require('!!css-loader!less-loader!./xxx.less');
</code></pre></div><p>所以从 Webpack 的角度看，实际上对同一个文件调用了两次 loader 链，第一次在 style-loader 的 pitch 中断，第二次根据 inline loader 的内容跳过了 style-loader。</p> <p>相似的技巧在其它仓库也有出现，比如 vue-loader，感兴趣的同学可以查看我之前发在 ByteFE 公众号上的文章《<a href="https://mp.weixin.qq.com/s?__biz=Mzg2ODQ1OTExOA==&amp;mid=2247487730&amp;idx=1&amp;sn=0678ba3acebfd67ce4e31128d313c89b&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">Webpack 案例 ——vue-loader 原理分析<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>》，这里就不展开讲了。</p> <h1 id="进阶技巧"><a href="#进阶技巧" class="header-anchor">#</a> 进阶技巧</h1> <h2 id="开发工具"><a href="#开发工具" class="header-anchor">#</a> 开发工具</h2> <p>Webpack 为 Loader 开发者提供了两个实用工具，在诸多开源 Loader 中出现频率极高：</p> <ul><li>webpack/loader-utils：提供了一系列诸如读取配置、requestString 序列化与反序列化、计算 hash 值之类的工具函数</li> <li>webpack/schema-utils：参数校验工具</li></ul> <p>这些工具的具体接口在相应的 readme 上已经有明确的说明，不赘述，这里总结一些编写 Loader 时经常用到的样例：如何获取并校验用户配置；如何拼接输出文件名。</p> <h3 id="获取并校验配置"><a href="#获取并校验配置" class="header-anchor">#</a> 获取并校验配置</h3> <p>Loader 通常都提供了一些配置项，供开发者定制运行行为，用户可以通过 Webpack 配置文件的 <code>use.options</code> 属性设定配置，例如：</p> <div class="language- extra-class"><pre class="language-text"><code>module.exports = {
  module: {
    rules: [{
      test: /\.less$/i,
      use: [
        {
          loader: &quot;less-loader&quot;,
          options: {
            cacheDirectory: false
          }
        },
      ],
    }],
  },
};
</code></pre></div><p>在 Loader 内部，需要使用 <code>loader-utils</code> 库的 <code>getOptions</code> 函数获取用户配置，用 <code>schema-utils</code> 库的 <code>validate</code> 函数校验参数合法性，例如 css-loader：</p> <div class="language- extra-class"><pre class="language-text"><code>// css-loader/src/index.js
import { getOptions } from &quot;loader-utils&quot;;
import { validate } from &quot;schema-utils&quot;;
import schema from &quot;./options.json&quot;;


export default async function loader(content, map, meta) {
  const rawOptions = getOptions(this);

  validate(schema, rawOptions, {
    name: &quot;CSS Loader&quot;,
    baseDataPath: &quot;options&quot;,
  });
  // ...
}
</code></pre></div><p>使用 <code>schema-utils</code> 做校验时需要提前声明配置模板，通常会处理成一个额外的 json 文件，例如上例中的 <code>&quot;./options.json&quot;</code>。</p> <h3 id="拼接输出文件名"><a href="#拼接输出文件名" class="header-anchor">#</a> 拼接输出文件名</h3> <p>Webpack 支持以类似 <code>[path]/[name]-[hash].js</code> 方式设定 <code>output.filename</code>即输出文件的命名，这一层规则通常不需要关注，但某些场景例如 webpack-contrib/file-loader 需要根据 asset 的文件名拼接结果。</p> <p><code>file-loader</code> 支持在 JS 模块中引入诸如 png、jpg、svg 等文本或二进制文件，并将文件写出到输出目录，这里面有一个问题：假如文件叫 <code>a.jpg</code> ，经过 Webpack 处理后输出为 <code>[hash].jpg</code> ，怎么对应上呢？此时就可以使用 <code>loader-utils</code> 提供的 <code>interpolateName</code> 在 <code>file-loader</code> 中获取资源写出的路径及名称，源码：</p> <div class="language- extra-class"><pre class="language-text"><code>import { getOptions, interpolateName } from 'loader-utils';

export default function loader(content) {
  const context = options.context || this.rootContext;
  const name = options.name || '[contenthash].[ext]';

  // 拼接最终输出的名称
  const url = interpolateName(this, name, {
    context,
    content,
    regExp: options.regExp,
  });

  let outputPath = url;
  // ...

  let publicPath = `__webpack_public_path__ + ${JSON.stringify(outputPath)}`;
  // ...

  if (typeof options.emitFile === 'undefined' || options.emitFile) {
    // ...

    // 提交、写出文件
    this.emitFile(outputPath, content, null, assetInfo);
  }
  // ...

  const esModule =
    typeof options.esModule !== 'undefined' ? options.esModule : true;

  // 返回模块化内容
  return `${esModule ? 'export default' : 'module.exports ='} ${publicPath};`;
}

export const raw = true;
</code></pre></div><p>代码的核心逻辑：</p> <ol><li>根据 Loader 配置，调用 <code>interpolateName</code> 方法拼接目标文件的完整路径</li> <li>调用上下文 <code>this.emitFile</code> 接口，写出文件</li> <li>返回 <code>module.exports = ${publicPath}</code> ，其它模块可以引用到该文件路径</li></ol> <p>除 file-loader 外，css-loader、eslint-loader 都有用到该接口，感兴趣的同学请自行前往查阅源码。</p> <h2 id="单元测试"><a href="#单元测试" class="header-anchor">#</a> 单元测试</h2> <p>在 Loader 中编写单元测试收益非常高，一方面对开发者来说不用去怎么写 demo，怎么搭建测试环境；一方面对于最终用户来说，带有一定测试覆盖率的项目通常意味着更高、更稳定的质量。</p> <p>阅读了超过 20 个开源项目后，我总结了一套 Webpack Loader 场景下常用的单元测试流程，以 Jest · 🃏 Delightful JavaScript Testing 为例：</p> <ol><li>创建在 Webpack 实例，并运行 Loader</li> <li>获取 Loader 执行结果，比对、分析判断是否符合预期</li> <li>判断执行过程中是否出错</li></ol> <h3 id="如何运行-loader"><a href="#如何运行-loader" class="header-anchor">#</a> 如何运行 Loader</h3> <p>有两种办法，一是在 node 环境下运行调用 Webpack 接口，用代码而非命令行执行编译，很多框架都会采用这种方式，例如 vue-loader、stylus-loader、babel-loader 等，优点的运行效果最接近最终用户，缺点是运行效率相对较低(可以忽略)。</p> <p>以 posthtml/posthtml-loader 为例，它会在启动测试之前创建并运行 Webpack 实例：</p> <div class="language- extra-class"><pre class="language-text"><code>// posthtml-loader/test/helpers/compiler.js 文件
module.exports = function (fixture, config, options) {
  config = { /*...*/ }

  options = Object.assign({ output: false }, options)

  // 创建 Webpack 实例
  const compiler = webpack(config)

  // 以 MemoryFS 方式输出构建结果，避免写磁盘
  if (!options.output) compiler.outputFileSystem = new MemoryFS()

  // 执行，并以 promise 方式返回结果
  return new Promise((resolve, reject) =&gt; compiler.run((err, stats) =&gt; {
    if (err) reject(err)
    // 异步返回执行结果
    resolve(stats)
  }))
}
</code></pre></div><blockquote><p>小技巧：如上例所示，用 <code>compiler.outputFileSystem = new MemoryFS()</code>语句将 Webpack 设定成输出到内存，能避免写盘操作，提升编译速度。</p></blockquote> <p>另外一种方法是编写一系列 mock 方法，搭建起一个模拟的 Webpack 运行环境，例如 emaphp/underscore-template-loader ，优点的运行速度更快，缺点是开发工作量大通用性低，了解了解即可。</p> <h3 id="比对结果"><a href="#比对结果" class="header-anchor">#</a> 比对结果</h3> <p>上例运行结束之后会以 <code>resolve(stats)</code> 方式返回执行结果，<code>stats</code> 对象中几乎包含了编译过程所有信息，包括耗时、产物、模块、chunks、errors、warnings 等等，我在之前的文章 <a href="https://mp.weixin.qq.com/s?__biz=Mzg3OTYwMjcxMA==&amp;mid=2247484005&amp;idx=1&amp;sn=ae3e478259a50c54e0282b2efbc28c3f&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">分享几个 Webpack 实用分析工具<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 对此已经做了较深入的介绍，感兴趣的同学可以前往阅读。</p> <p>在测试场景下，可以从 <code>stats</code> 对象中读取编译最终输出的产物，例如 style-loader 的实现：</p> <div class="language- extra-class"><pre class="language-text"><code>// style-loader/src/test/helpers/readAsset.js 文件
function readAsset(compiler, stats, assets) =&gt; {
  const usedFs = compiler.outputFileSystem
  const outputPath = stats.compilation.outputOptions.path
  const queryStringIdx = targetFile.indexOf('?')

  if (queryStringIdx &gt;= 0) {
    // 解析出输出文件路径
    asset = asset.substr(0, queryStringIdx)
  }

  // 读文件内容
  return usedFs.readFileSync(path.join(outputPath, targetFile)).toString()
}
</code></pre></div><p>解释一下，这段代码首先计算 asset 输出的文件路径，之后调用 outputFileSystem 的 <code>readFile</code> 方法读取文件内容。</p> <p>接下来，有两种分析内容的方法：</p> <ul><li>调用 Jest 的 <code>expect(xxx).toMatchSnapshot()</code> 断言判断当前运行结果是否与之前的运行结果一致，从而确保多次修改的结果一致性，很多框架都大量用了这种方法</li> <li>解读资源内容，判断是否符合预期，例如 less-loader 的单元测试中会对同一份代码跑两次 less 编译，一次由 Webpack 执行，一次直接调用 <code>less</code> 库，之后分析两次运行结果是否相同</li></ul> <p>对此有兴趣的同学，强烈建议看看 <code>less-loader</code> 的 test 目录。</p> <h3 id="异常判断"><a href="#异常判断" class="header-anchor">#</a> 异常判断</h3> <p>最后，还需要判断编译过程是否出现异常，同样可以从 <code>stats</code> 对象解析：</p> <div class="language- extra-class"><pre class="language-text"><code>export default getErrors = (stats) =&gt; {
  const errors = stats.compilation.errors.sort()
  return errors.map(
    e =&gt; e.toString()
  )
}
</code></pre></div><p>大多数情况下都希望编译没有错误，此时只要判断结果数组是否为空即可。某些情况下可能需要判断是否抛出特定异常，此时可以 <code>expect(xxx).toMatchSnapshot()</code> 断言，用快照对比更新前后的结果。</p> <h2 id="调试"><a href="#调试" class="header-anchor">#</a> 调试</h2> <p>开发 Loader 的过程中，有一些小技巧能够提升调试效率，包括：</p> <ul><li>使用 ndb 工具实现断点调试</li> <li>使用 <code>npm link</code> 将 Loader 模块链接到测试项目</li> <li>使用 <code>resolveLoader</code> 配置项将 Loader 所在的目录加入到测试项目中，如：</li></ul> <div class="language- extra-class"><pre class="language-text"><code>// webpack.config.js
module.exports = {
  resolveLoader:{
    modules: ['node_modules','./loaders/'],
  }
}
</code></pre></div><h1 id="无关紧要总结"><a href="#无关紧要总结" class="header-anchor">#</a> 无关紧要总结</h1> <p>这是 Webpack 原理分析系列第七篇文章，说实话最开始并没有想到能写这么多，后续还会继续 focus 在这个前端工程化领域，我的目标是能攒成一本自己的书，感兴趣的同学欢迎点赞关注，如果觉得有什么地方遗漏、疑惑，欢迎评论讨论。</p> <p><img src="http://mmbiz.qpic.cn/mmbiz_png/3xDuJ3eiciblkrkIk3XeyL1jc2o7J5FUibbjapRDRicM4S9rFHhoJFK8EBW9SWf8CPO8pSSanB9oo3dD4VPThlbeeA/0?wx_fmt=png" alt="Tecvan"></p> <p><strong>Tecvan</strong></p> <p>专注前端框架源码解读</p> <p>18篇原创内容</p> <p>公众号</p> <blockquote><p>往期文章</p> <ul><li><a href="https://mp.weixin.qq.com/s?__biz=Mzg3OTYwMjcxMA==&amp;mid=2247484005&amp;idx=1&amp;sn=ae3e478259a50c54e0282b2efbc28c3f&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">分享几个 Webpack 实用分析工具<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li>[建议收藏] Webpack 4+ 优秀学习资料合集</li> <li>[<a href="https://mp.weixin.qq.com/s?__biz=Mzg3OTYwMjcxMA==&amp;mid=2247483744&amp;idx=1&amp;sn=d7128a76eed20746cd8c5100f0899138&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">万字总结] 一文吃透 Webpack 核心原理<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li>[<a href="https://mp.weixin.qq.com/s?__biz=Mzg3OTYwMjcxMA==&amp;mid=2247483941&amp;idx=1&amp;sn=ce7597dfc8784e66d3c58f0e8df51f6b&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">源码解读] Webpack 插件架构深度讲解<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="https://mp.weixin.qq.com/s?__biz=Mzg3OTYwMjcxMA==&amp;mid=2247483956&amp;idx=1&amp;sn=a2066fcc76cd97de88a6d6cb397e6c2a&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">十分钟精进 Webpack：module.issuer 属性详解<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="https://mp.weixin.qq.com/s?__biz=Mzg3OTYwMjcxMA==&amp;mid=2247483743&amp;idx=1&amp;sn=0ce0845ee3e5316bcac05993035de3ed&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">有点难的 webpack 知识点：Dependency Graph 深度解析<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="https://mp.weixin.qq.com/s?__biz=Mzg3OTYwMjcxMA==&amp;mid=2247484029&amp;idx=1&amp;sn=7862737524e799c5eaf1605325171e32&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">有点难的知识点：Webpack Chunk 分包规则详解<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="https://mp.weixin.qq.com/s?__biz=Mzg3OTYwMjcxMA==&amp;mid=2247484088&amp;idx=1&amp;sn=41bf509a72f2cbcca1521747bf5e28f4&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">Webpack 原理系列六：彻底理解 Webpack 运行时<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></blockquote></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">上次更新:</span> <span class="time">5/8/2024, 3:01:19 PM</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/webpack/1-webpack原理/Webpack原理系列一-一文吃透Webpack核心原理.html" class="prev">
        一文吃透 Webpack 核心原理
      </a></span> <span class="next"><a href="/webpack/1-webpack原理/Webpack原理系列九-Tree-Shaking实现原理.html">
        Webpack 原理系列九：Tree-Shaking实现原理
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"><!----><!----></div></div>
    <script src="/assets/js/app.04fd048c.js" defer></script><script src="/assets/js/2.57da4f88.js" defer></script><script src="/assets/js/1.a76cc220.js" defer></script><script src="/assets/js/49.3039c755.js" defer></script>
  </body>
</html>

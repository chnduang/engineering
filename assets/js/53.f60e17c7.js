(window.webpackJsonp=window.webpackJsonp||[]).push([[53],{344:function(e,n,t){"use strict";t.r(n);var _=t(4),a=Object(_.a)({},(function(){var e=this,n=e._self._c;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("h1",{attrs:{id:"webpack-原理系列八-产物转译打包逻辑"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#webpack-原理系列八-产物转译打包逻辑"}},[e._v("#")]),e._v(" Webpack 原理系列八：产物转译打包逻辑")]),e._v(" "),n("p",[e._v("回顾一下，在之前的文章《"),n("a",{attrs:{href:"https://mp.weixin.qq.com/s?__biz=Mzg3OTYwMjcxMA==&mid=2247483743&idx=1&sn=0ce0845ee3e5316bcac05993035de3ed&scene=21#wechat_redirect",target:"_blank",rel:"noopener noreferrer"}},[e._v("有点难的 webpack 知识点：Dependency Graph 深度解析"),n("OutboundLink")],1),e._v("》已经聊到，经过 "),n("strong",[e._v("「构建(make)阶段」")]),e._v(" 后，Webpack 解析出：")]),e._v(" "),n("ul",[n("li",[n("code",[e._v("module")]),e._v(" 内容")]),e._v(" "),n("li",[n("code",[e._v("module")]),e._v(" 与 "),n("code",[e._v("module")]),e._v(" 之间的依赖关系图")])]),e._v(" "),n("p",[n("img",{attrs:{src:"https://mmbiz.qpic.cn/mmbiz_png/3xDuJ3eiciblmia3JopT4kmIiafFMQPLNWTQoDZYw61pngiaV1xsBwgtwFKWsK6WgicSMibvaJ9HhXAic09zg060eYeYibA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1",alt:"图片"}})]),e._v(" "),n("p",[e._v("而进入 "),n("strong",[e._v("「生成(*"),n("em",[e._v("「**「seal」**」*")]),e._v(")阶段」")]),e._v(" 后，Webpack 首先根据模块的依赖关系、模块特性、entry配置等计算出 Chunk Graph，确定最终产物的数量和内容，这部分原理在前文《"),n("a",{attrs:{href:"https://mp.weixin.qq.com/s?__biz=Mzg3OTYwMjcxMA==&mid=2247484029&idx=1&sn=7862737524e799c5eaf1605325171e32&scene=21#wechat_redirect",target:"_blank",rel:"noopener noreferrer"}},[e._v("有点难的知识点：Webpack Chunk 分包规则详解"),n("OutboundLink")],1),e._v("》中也有较详细的描述。")]),e._v(" "),n("p",[e._v("本文继续聊聊 Chunk Graph 后面之后，模块开始转译到模块合并打包的过程，大体流程如下：")]),e._v(" "),n("p",[n("img",{attrs:{src:"https://mmbiz.qpic.cn/mmbiz_png/3xDuJ3eiciblmia3JopT4kmIiafFMQPLNWTQicdq5Fls6NsTZnro0EdTfGf1aib7icUgcjDtxwTa76yWCFMnJkhCzicUrA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1",alt:"图片"}})]),e._v(" "),n("p",[e._v("为了方便理解，我将打包过程横向切分为三个阶段：")]),e._v(" "),n("ul",[n("li",[n("strong",[e._v("「入口」")]),e._v("：指代从 Webpack 启动到调用 "),n("code",[e._v("compilation.codeGeneration")]),e._v(" 之前的所有前置操作")]),e._v(" "),n("li",[n("strong",[e._v("「模块转译」")]),e._v("：遍历 "),n("code",[e._v("modules")]),e._v(" 数组，完成所有模块的转译操作，并将结果存储到 "),n("code",[e._v("compilation.codeGenerationResults")]),e._v(" 对象")]),e._v(" "),n("li",[n("strong",[e._v("「模块合并打包」")]),e._v("：在特定上下文框架下，组合业务模块、runtime 模块，合并打包成 bundle ，并调用 "),n("code",[e._v("compilation.emitAsset")]),e._v(" 输出产物")])]),e._v(" "),n("p",[e._v("这里说的 "),n("strong",[e._v("「业务模块」")]),e._v(" 是指开发者所编写的项目代码；"),n("strong",[e._v("「runtime 模块」")]),e._v(" 是指 Webpack 分析业务模块后，动态注入的用于支撑各项特性的运行时代码，在上一篇文章 "),n("a",{attrs:{href:"https://mp.weixin.qq.com/s?__biz=Mzg3OTYwMjcxMA==&mid=2247484088&idx=1&sn=41bf509a72f2cbcca1521747bf5e28f4&scene=21#wechat_redirect",target:"_blank",rel:"noopener noreferrer"}},[e._v("Webpack 原理系列六：彻底理解 Webpack 运行时"),n("OutboundLink")],1),e._v(" 已经有详细讲解，这里不赘述。")]),e._v(" "),n("p",[e._v("可以看到，Webpack 先将 "),n("code",[e._v("modules")]),e._v(" 逐一转译为模块产物 —— "),n("strong",[e._v("「模块转译」")]),e._v("，再将模块产物拼接成 bundle —— "),n("strong",[e._v("「模块合并打包」")]),e._v("，我们下面会按照这个逻辑分开讨论这两个过程的原理。")]),e._v(" "),n("h1",{attrs:{id:"一、模块转译原理"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#一、模块转译原理"}},[e._v("#")]),e._v(" 一、模块转译原理")]),e._v(" "),n("h2",{attrs:{id:"_1-1-简介"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_1-1-简介"}},[e._v("#")]),e._v(" 1.1 简介")]),e._v(" "),n("p",[e._v("先回顾一下 Webpack 产物：")]),e._v(" "),n("p",[n("img",{attrs:{src:"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==",alt:"图片"}})]),e._v(" "),n("p",[e._v("上述示例由 "),n("code",[e._v("index.js")]),e._v(" / "),n("code",[e._v("name.js")]),e._v(" 两个业务文件组成，对应的 Webpack 配置如上图左下角所示；Webpack 构建产物如右边 "),n("code",[e._v("main.js")]),e._v(" 文件所示，包含三块内容，从上到下分别为：")]),e._v(" "),n("ul",[n("li",[n("code",[e._v("name.js")]),e._v(" 模块对应的转译产物，函数形态")]),e._v(" "),n("li",[e._v("Webpack 按需注入的运行时代码")]),e._v(" "),n("li",[n("code",[e._v("index.js")]),e._v(" 模块对应的转译产物，IIFE(立即执行函数) 形态")])]),e._v(" "),n("p",[e._v("其中，运行时代码的作用与生成逻辑在上篇文章 "),n("a",{attrs:{href:"https://mp.weixin.qq.com/s?__biz=Mzg3OTYwMjcxMA==&mid=2247484088&idx=1&sn=41bf509a72f2cbcca1521747bf5e28f4&scene=21#wechat_redirect",target:"_blank",rel:"noopener noreferrer"}},[e._v("Webpack 原理系列六：彻底理解 Webpack 运行时"),n("OutboundLink")],1),e._v(" 已有详尽介绍；另外两块分别为 "),n("code",[e._v("name.js")]),e._v(" 、"),n("code",[e._v("index.js")]),e._v(" 构建后的产物，可以看到产物与源码语义、功能均相同，但表现形式发生了较大变化，例如 "),n("code",[e._v("index.js")]),e._v(" 编译前后的内容：")]),e._v(" "),n("p",[n("img",{attrs:{src:"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==",alt:"图片"}})]),e._v(" "),n("p",[e._v("上图右边是 Webpack 编译产物中对应的代码，相对于左边的源码有如下变化：")]),e._v(" "),n("ul",[n("li",[e._v("整个模块被包裹进 IIFE (立即执行函数)中")]),e._v(" "),n("li",[e._v("添加 "),n("code",[e._v("__webpack_require__.r(__webpack_exports__);")]),e._v(" 语句，用于适配 ESM 规范")]),e._v(" "),n("li",[e._v("源码中的 "),n("code",[e._v("import")]),e._v(" 语句被转译为 "),n("code",[e._v("__webpack_require__")]),e._v(" 函数调用")]),e._v(" "),n("li",[e._v("源码 "),n("code",[e._v("console")]),e._v(" 语句所使用的 "),n("code",[e._v("name")]),e._v(" 变量被转译为 "),n("code",[e._v("_name__WEBPACK_IMPORTED_MODULE_0__.default")])]),e._v(" "),n("li",[e._v("添加注释")])]),e._v(" "),n("p",[e._v("那么 Webpack 中如何执行这些转换的呢？")]),e._v(" "),n("h2",{attrs:{id:"_1-2-核心流程"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_1-2-核心流程"}},[e._v("#")]),e._v(" 1.2 核心流程")]),e._v(" "),n("p",[n("strong",[e._v("「模块转译」")]),e._v(" 操作从 "),n("code",[e._v("module.codeGeneration")]),e._v(" 调用开始，对应到上述流程图的：")]),e._v(" "),n("p",[n("img",{attrs:{src:"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==",alt:"图片"}})]),e._v(" "),n("p",[e._v("总结一下关键步骤：")]),e._v(" "),n("ul",[n("li",[n("p",[e._v("调用 "),n("code",[e._v("JavascriptGenerator")]),e._v(" 的对象的 "),n("code",[e._v("generate")]),e._v(" 方法，方法内部：")])]),e._v(" "),n("li",[n("ul",[n("li",[e._v("遍历模块的 "),n("code",[e._v("dependencies")]),e._v(" 与 "),n("code",[e._v("presentationalDependencies")]),e._v(" 数组")]),e._v(" "),n("li",[e._v("执行每个数组项 "),n("code",[e._v("dependeny")]),e._v(" 对象的对应的 "),n("code",[e._v("template.apply")]),e._v(" 方法，在 "),n("code",[e._v("apply")]),e._v("内修改模块代码，或更新 "),n("code",[e._v("initFragments")]),e._v(" 数组")])])]),e._v(" "),n("li",[n("p",[e._v("遍历完毕后，调用 "),n("code",[e._v("InitFragment.addToSource")]),e._v(" 静态方法，将上一步操作产生的 "),n("code",[e._v("source")]),e._v(" 对象与 "),n("code",[e._v("initFragments")]),e._v(" 数组合并为模块产物")])])]),e._v(" "),n("p",[e._v("简单说就是遍历依赖，在依赖对象中修改 "),n("code",[e._v("module")]),e._v(" 代码，最后再将所有变更合并为最终产物。这里面关键点：")]),e._v(" "),n("ul",[n("li",[e._v("在 "),n("code",[e._v("Template.apply")]),e._v(" 函数中，如何更新模块代码")]),e._v(" "),n("li",[e._v("在 "),n("code",[e._v("InitFragment.addToSource")]),e._v(" 静态方法中，如何将 "),n("code",[e._v("Template.apply")]),e._v(" 所产生的 side effect 合并为最终产物")])]),e._v(" "),n("p",[e._v("这两部分逻辑比较复杂，下面分开讲解。")]),e._v(" "),n("h2",{attrs:{id:"_1-3-template-apply-函数"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_1-3-template-apply-函数"}},[e._v("#")]),e._v(" 1.3 Template.apply 函数")]),e._v(" "),n("p",[e._v("上述流程中，"),n("code",[e._v("JavascriptGenerator")]),e._v(" 类是毋庸置疑的C位角色，但它并不直接修改 "),n("code",[e._v("module")]),e._v(" 的内容，而是绕了几层后委托交由 "),n("code",[e._v("Template")]),e._v(" 类型实现。")]),e._v(" "),n("p",[e._v("Webpack 5 源码中，"),n("code",[e._v("JavascriptGenerator.generate")]),e._v(" 函数会遍历模块的 "),n("code",[e._v("dependencies")]),e._v(" 数组，调用依赖对象对应的 "),n("code",[e._v("Template")]),e._v(" 子类 "),n("code",[e._v("apply")]),e._v(" 方法更新模块内容，说起来有点绕，原始代码更饶，所以我将重要步骤抽取为如下伪代码：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("class JavascriptGenerator {\n    generate(module, generateContext) {\n        // 先取出 module 的原始代码内容\n        const source = new ReplaceSource(module.originalSource());\n        const { dependencies, presentationalDependencies } = module;\n        const initFragments = [];\n        for (const dependency of [...dependencies, ...presentationalDependencies]) {\n            // 找到 dependency 对应的 template\n            const template = generateContext.dependencyTemplates.get(dependency.constructor);\n            // 调用 template.apply，传入 source、initFragments\n            // 在 apply 函数可以直接修改 source 内容，或者更改 initFragments 数组，影响后续转译逻辑\n            template.apply(dependency, source, {initFragments})\n        }\n        // 遍历完毕后，调用 InitFragment.addToSource 合并 source 与 initFragments\n        return InitFragment.addToSource(source, initFragments, generateContext);\n    }\n}\n\n// Dependency 子类\nclass xxxDependency extends Dependency {}\n\n// Dependency 子类对应的 Template 定义\nconst xxxDependency.Template = class xxxDependencyTemplate extends Template {\n    apply(dep, source, {initFragments}) {\n        // 1. 直接操作 source，更改模块代码\n        source.replace(dep.range[0], dep.range[1] - 1, 'some thing')\n        // 2. 通过添加 InitFragment 实例，补充代码\n        initFragments.push(new xxxInitFragment())\n    }\n}\n")])])]),n("p",[e._v("从上述伪代码可以看出，"),n("code",[e._v("JavascriptGenerator.generate")]),e._v(" 函数的逻辑相对比较固化：")]),e._v(" "),n("ol",[n("li",[e._v("初始化一系列变量")]),e._v(" "),n("li",[e._v("遍历 "),n("code",[e._v("module")]),e._v(" 对象的依赖数组，找到每个 "),n("code",[e._v("dependency")]),e._v(" 对应的 "),n("code",[e._v("template")]),e._v(" 对象，调用 "),n("code",[e._v("template.apply")]),e._v(" 函数修改模块内容")]),e._v(" "),n("li",[e._v("调用 "),n("code",[e._v("InitFragment.addToSource")]),e._v(" 方法，合并 "),n("code",[e._v("source")]),e._v(" 与 "),n("code",[e._v("initFragments")]),e._v("数组，生成最终结果")])]),e._v(" "),n("p",[e._v("这里的重点是 "),n("code",[e._v("JavascriptGenerator.generate")]),e._v(" 函数并不操作 "),n("code",[e._v("module")]),e._v(" 源码，它仅仅提供一个执行框架，真正处理模块内容转译的逻辑都在 "),n("code",[e._v("xxxDependencyTemplate")]),e._v("对象的 "),n("code",[e._v("apply")]),e._v(" 函数实现，如上例伪代码中 24-28行。")]),e._v(" "),n("p",[e._v("每个 "),n("code",[e._v("Dependency")]),e._v(" 子类都会映射到一个唯一的 "),n("code",[e._v("Template")]),e._v(" 子类，且通常这两个类都会写在同一个文件中，例如 "),n("code",[e._v("ConstDependency")]),e._v(" 与 "),n("code",[e._v("ConstDependencyTemplate")]),e._v("；"),n("code",[e._v("NullDependency")]),e._v(" 与 "),n("code",[e._v("NullDependencyTemplate")]),e._v("。Webpack 构建(make)阶段，会通过 "),n("code",[e._v("Dependency")]),e._v(" 子类记录不同情况下模块之间的依赖关系；到生成(seal)阶段再通过 "),n("code",[e._v("Template")]),e._v(" 子类修改 "),n("code",[e._v("module")]),e._v(" 代码。")]),e._v(" "),n("p",[e._v("综上 "),n("code",[e._v("Module")]),e._v("、"),n("code",[e._v("JavascriptGenerator")]),e._v("、"),n("code",[e._v("Dependency")]),e._v("、"),n("code",[e._v("Template")]),e._v(" 四个类形成如下交互关系：")]),e._v(" "),n("p",[n("img",{attrs:{src:"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==",alt:"图片"}})]),e._v(" "),n("p",[n("code",[e._v("Template")]),e._v(" 对象可以通过两种方法更新 "),n("code",[e._v("module")]),e._v(" 的代码：")]),e._v(" "),n("ul",[n("li",[e._v("直接操作 "),n("code",[e._v("source")]),e._v(" 对象，直接修改模块代码，该对象最初的内容等于模块的源码，经过多个 "),n("code",[e._v("Template.apply")]),e._v(" 函数流转后逐渐被替换成新的代码形式")]),e._v(" "),n("li",[e._v("操作 "),n("code",[e._v("initFragments")]),e._v(" 数组，在模块源码之外插入补充代码片段")])]),e._v(" "),n("p",[e._v("这两种操作所产生的 side effect，最终都会被传入 "),n("code",[e._v("InitFragment.addToSource")]),e._v(" 函数，合成最终结果，下面简单补充一些细节。")]),e._v(" "),n("h3",{attrs:{id:"_1-3-1-使用-source-更改代码"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_1-3-1-使用-source-更改代码"}},[e._v("#")]),e._v(" 1.3.1 使用 Source 更改代码")]),e._v(" "),n("p",[n("code",[e._v("Source")]),e._v(" 是 Webpack 中编辑字符串的一套工具体系，提供了一系列字符串操作方法，包括：")]),e._v(" "),n("ul",[n("li",[e._v("字符串合并、替换、插入等")]),e._v(" "),n("li",[e._v("模块代码缓存、sourcemap 映射、hash 计算等")])]),e._v(" "),n("p",[e._v("Webpack 内部以及社区的很多插件、loader 都会使用 "),n("code",[e._v("Source")]),e._v(" 库编辑代码内容，包括上文介绍的 "),n("code",[e._v("Template.apply")]),e._v(" 体系中，逻辑上，在启动模块代码生成流程时，Webpack 会先用模块原本的内容初始化 "),n("code",[e._v("Source")]),e._v(" 对象，即：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("const source = new ReplaceSource(module.originalSource());\n")])])]),n("p",[e._v("之后，不同 "),n("code",[e._v("Dependency")]),e._v(" 子类按序、按需更改 "),n("code",[e._v("source")]),e._v(" 内容，例如 "),n("code",[e._v("ConstDependencyTemplate")]),e._v(" 中的核心代码：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('ConstDependency.Template = class ConstDependencyTemplate extends (\n  NullDependency.Template\n) {\n  apply(dependency, source, templateContext) {\n    // ...\n    if (typeof dep.range === "number") {\n      source.insert(dep.range, dep.expression);\n      return;\n    }\n\n    source.replace(dep.range[0], dep.range[1] - 1, dep.expression);\n  }\n};\n')])])]),n("p",[e._v("上述 "),n("code",[e._v("ConstDependencyTemplate")]),e._v(" 中，apply 函数根据参数条件调用 "),n("code",[e._v("source.insert")]),e._v(" 插入一段代码，或者调用 "),n("code",[e._v("source.replace")]),e._v(" 替换一段代码。")]),e._v(" "),n("h3",{attrs:{id:"_1-3-2-使用-initfragment-更新代码"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_1-3-2-使用-initfragment-更新代码"}},[e._v("#")]),e._v(" 1.3.2 使用 InitFragment 更新代码")]),e._v(" "),n("p",[e._v("除直接操作 "),n("code",[e._v("source")]),e._v(" 外，"),n("code",[e._v("Template.apply")]),e._v(" 中还可以通过操作 "),n("code",[e._v("initFragments")]),e._v(" 数组达成修改模块产物的效果。"),n("code",[e._v("initFragments")]),e._v(" 数组项通常为 "),n("code",[e._v("InitFragment")]),e._v(" 子类实例，它们通常带有两个函数："),n("code",[e._v("getContent")]),e._v("、"),n("code",[e._v("getEndContent")]),e._v("，分别用于获取代码片段的头尾部分。")]),e._v(" "),n("p",[e._v("例如 "),n("code",[e._v("HarmonyImportDependencyTemplate")]),e._v(" 的 "),n("code",[e._v("apply")]),e._v(" 函数中：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("HarmonyImportDependency.Template = class HarmonyImportDependencyTemplate extends (\n  ModuleDependency.Template\n) {\n  apply(dependency, source, templateContext) {\n    // ...\n    templateContext.initFragments.push(\n        new ConditionalInitFragment(\n          importStatement[0] + importStatement[1],\n          InitFragment.STAGE_HARMONY_IMPORTS,\n          dep.sourceOrder,\n          key,\n          runtimeCondition\n        )\n      );\n    //...\n  }\n }\n")])])]),n("h2",{attrs:{id:"_1-4-代码合并"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_1-4-代码合并"}},[e._v("#")]),e._v(" 1.4 代码合并")]),e._v(" "),n("p",[e._v("上述 "),n("code",[e._v("Template.apply")]),e._v(" 处理完毕后，产生转译后的 "),n("code",[e._v("source")]),e._v(" 对象与代码片段 "),n("code",[e._v("initFragments")]),e._v(" 数组，接着就需要调用 "),n("code",[e._v("InitFragment.addToSource")]),e._v(" 函数将两者合并为模块产物。")]),e._v(" "),n("p",[n("code",[e._v("addToSource")]),e._v(" 的核心代码如下：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("class InitFragment {\n  static addToSource(source, initFragments, generateContext) {\n    // 先排好顺序\n    const sortedFragments = initFragments\n      .map(extractFragmentIndex)\n      .sort(sortFragmentWithIndex);\n    // ...\n\n    const concatSource = new ConcatSource();\n    const endContents = [];\n    for (const fragment of sortedFragments) {\n        // 合并 fragment.getContent 取出的片段内容\n      concatSource.add(fragment.getContent(generateContext));\n      const endContent = fragment.getEndContent(generateContext);\n      if (endContent) {\n        endContents.push(endContent);\n      }\n    }\n\n    // 合并 source\n    concatSource.add(source);\n    // 合并 fragment.getEndContent 取出的片段内容\n    for (const content of endContents.reverse()) {\n      concatSource.add(content);\n    }\n    return concatSource;\n  }\n}\n")])])]),n("p",[e._v("可以看到，"),n("code",[e._v("addToSource")]),e._v(" 函数的逻辑：")]),e._v(" "),n("ul",[n("li",[e._v("遍历 "),n("code",[e._v("initFragments")]),e._v(" 数组，按顺序合并 "),n("code",[e._v("fragment.getContent()")]),e._v(" 的产物")]),e._v(" "),n("li",[e._v("合并 "),n("code",[e._v("source")]),e._v(" 对象")]),e._v(" "),n("li",[e._v("遍历 "),n("code",[e._v("initFragments")]),e._v(" 数组，按顺序合并 "),n("code",[e._v("fragment.getEndContent()")]),e._v(" 的产物")])]),e._v(" "),n("p",[e._v("所以，模块代码合并操作主要就是用 "),n("code",[e._v("initFragments")]),e._v(" 数组一层一层包裹住模块代码 "),n("code",[e._v("source")]),e._v("，而两者都在 "),n("code",[e._v("Template.apply")]),e._v(" 层面维护。")]),e._v(" "),n("h2",{attrs:{id:"_1-5-示例-自定义-banner-插件"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_1-5-示例-自定义-banner-插件"}},[e._v("#")]),e._v(" 1.5 示例：自定义 banner 插件")]),e._v(" "),n("p",[e._v("经过 "),n("code",[e._v("Template.apply")]),e._v(" 转译与 "),n("code",[e._v("InitFragment.addToSource")]),e._v(" 合并之后，模块就完成了从用户代码形态到产物形态的转变，为加深对上述 "),n("strong",[e._v("「模块转译」")]),e._v(" 流程的理解，接下来我们尝试开发一个 Banner 插件，实现在每个模块前自动插入一段字符串。")]),e._v(" "),n("p",[e._v("实现上，插件主要涉及 "),n("code",[e._v("Dependency")]),e._v("、"),n("code",[e._v("Template")]),e._v("、"),n("code",[e._v("hooks")]),e._v(" 对象，代码：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('const { Dependency, Template } = require("webpack");\n\nclass DemoDependency extends Dependency {\n  constructor() {\n    super();\n  }\n}\n\nDemoDependency.Template = class DemoDependencyTemplate extends Template {\n  apply(dependency, source) {\n    const today = new Date().toLocaleDateString();\n    source.insert(0, `/* Author: Tecvan */\n/* Date: ${today} */\n`);\n  }\n};\n\nmodule.exports = class DemoPlugin {\n  apply(compiler) {\n    compiler.hooks.thisCompilation.tap("DemoPlugin", (compilation) => {\n      // 调用 dependencyTemplates ，注册 Dependency 到 Template 的映射\n      compilation.dependencyTemplates.set(\n        DemoDependency,\n        new DemoDependency.Template()\n      );\n      compilation.hooks.succeedModule.tap("DemoPlugin", (module) => {\n        // 模块构建完毕后，插入 DemoDependency 对象\n        module.addDependency(new DemoDependency());\n      });\n    });\n  }\n};\n')])])]),n("p",[e._v("示例插件的关键步骤：")]),e._v(" "),n("ul",[n("li",[e._v("编写 "),n("code",[e._v("DemoDependency")]),e._v(" 与 "),n("code",[e._v("DemoDependencyTemplate")]),e._v(" 类，其中 "),n("code",[e._v("DemoDependency")]),e._v(" 仅做示例用，没有实际功能；"),n("code",[e._v("DemoDependencyTemplate")]),e._v(" 则在其 "),n("code",[e._v("apply")]),e._v(" 中调用 "),n("code",[e._v("source.insert")]),e._v(" 插入字符串，如示例代码第 10-14 行")]),e._v(" "),n("li",[e._v("使用 "),n("code",[e._v("compilation.dependencyTemplates")]),e._v(" 注册 "),n("code",[e._v("DemoDependency")]),e._v(" 与 "),n("code",[e._v("DemoDependencyTemplate")]),e._v(" 的映射关系")]),e._v(" "),n("li",[e._v("使用 "),n("code",[e._v("thisCompilation")]),e._v(" 钩子取得 "),n("code",[e._v("compilation")]),e._v(" 对象")]),e._v(" "),n("li",[e._v("使用 "),n("code",[e._v("succeedModule")]),e._v(" 钩子订阅 "),n("code",[e._v("module")]),e._v(" 构建完毕事件，并调用 "),n("code",[e._v("module.addDependency")]),e._v(" 方法添加 "),n("code",[e._v("DemoDependency")]),e._v(" 依赖")])]),e._v(" "),n("p",[e._v("完成上述操作后，"),n("code",[e._v("module")]),e._v(" 对象的产物在生成过程就会调用到 "),n("code",[e._v("DemoDependencyTemplate.apply")]),e._v(" 函数，插入我们定义好的字符串，效果如：")]),e._v(" "),n("p",[n("img",{attrs:{src:"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==",alt:"图片"}})]),e._v(" "),n("blockquote",[n("p",[e._v("感兴趣的读者也可以直接阅读 Webpack 5 仓库的如下文件，学习更多用例：")]),e._v(" "),n("ul",[n("li",[e._v("lib/dependencies/ConstDependency.js，一个简单示例，可学习 "),n("code",[e._v("source")]),e._v(" 的更多操作方法")]),e._v(" "),n("li",[e._v("lib/dependencies/HarmonyExportSpecifierDependencyTemplate.js，一个简单示例，可学习 "),n("code",[e._v("initFragments")]),e._v(" 数组的更多用法")]),e._v(" "),n("li",[e._v("lib/dependencies/HarmonyImportDependencyTemplate.js，一个较复杂但使用率极高的示例，可综合学习 "),n("code",[e._v("source")]),e._v("、"),n("code",[e._v("initFragments")]),e._v(" 数组的用法")])])]),e._v(" "),n("h1",{attrs:{id:"二、模块合并打包原理"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#二、模块合并打包原理"}},[e._v("#")]),e._v(" 二、模块合并打包原理")]),e._v(" "),n("h2",{attrs:{id:"_2-1-简介"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-简介"}},[e._v("#")]),e._v(" 2.1 简介")]),e._v(" "),n("p",[e._v("讲完单个模块的转译过程后，我们先回到这个流程图：")]),e._v(" "),n("p",[n("img",{attrs:{src:"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==",alt:"图片"}})]),e._v(" "),n("p",[e._v("流程图中，"),n("code",[e._v("compilation.codeGeneration")]),e._v(" 函数执行完毕 —— 也就是模块转译阶段完成后，模块的转译结果会一一保存到 "),n("code",[e._v("compilation.codeGenerationResults")]),e._v(" 对象中，之后会启动一个新的执行流程 —— "),n("strong",[e._v("「模块合并打包」")]),e._v("。")]),e._v(" "),n("p",[n("strong",[e._v("「模块合并打包」")]),e._v(" 过程会将 chunk 对应的 module 及 runtimeModule 按规则塞进 "),n("strong",[e._v("「模板框架」")]),e._v(" 中，最终合并输出成完整的 bundle 文件，例如上例中：")]),e._v(" "),n("p",[n("img",{attrs:{src:"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==",alt:"图片"}})]),e._v(" "),n("p",[e._v("示例右边 bundle 文件中，红框框出来的部分为用户代码文件及运行时模块生成的产物，其余部分撑起了一个 IIFE 形式的运行框架即为 "),n("strong",[e._v("「模板框架」")]),e._v("，也就是：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('(() => { // webpackBootstrap\n    "use strict";\n    var __webpack_modules__ = ({\n        "module-a": ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n            // ! module 代码，\n        }),\n        "module-b": ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n            // ! module 代码，\n        })\n    });\n    // The module cache\n    var __webpack_module_cache__ = {};\n    // The require function\n    function __webpack_require__(moduleId) {\n        // ! webpack CMD 实现\n    }\n    /************************************************************************/\n    // ! 各种 runtime\n    /************************************************************************/\n    var __webpack_exports__ = {};\n    // This entry need to be wrapped in an IIFE because it need to be isolated against other modules in the chunk.\n    (() => {\n        // ! entry 模块\n    })();\n})();\n')])])]),n("p",[e._v("捋一下这里的逻辑，运行框架包含如下关键部分：")]),e._v(" "),n("ul",[n("li",[e._v("最外层由一个 IIFE 包裹")]),e._v(" "),n("li",[e._v("一个记录了除 "),n("code",[e._v("entry")]),e._v(" 外的其它模块代码的 "),n("code",[e._v("__webpack_modules__")]),e._v(" 对象，对象的 key 为模块标志符；值为模块转译后的代码")]),e._v(" "),n("li",[e._v("一个极度简化的 CMD 实现："),n("code",[e._v("__webpack_require__")]),e._v(" 函数")]),e._v(" "),n("li",[e._v("最后，一个包裹了 "),n("code",[e._v("entry")]),e._v(" 代码的 IIFE 函数")])]),e._v(" "),n("p",[n("strong",[e._v("「模块转译」")]),e._v(" 是将 "),n("code",[e._v("module")]),e._v(" 转译为可以在宿主环境如浏览器上运行的代码形式；而 "),n("strong",[e._v("「模块合并」")]),e._v(" 操作则串联这些 "),n("code",[e._v("modules")]),e._v(" ，使之整体符合开发预期，能够正常运行整个应用逻辑。接下来，我们揭晓这部分代码的生成原理。")]),e._v(" "),n("h2",{attrs:{id:"_2-2-核心流程"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-核心流程"}},[e._v("#")]),e._v(" 2.2 核心流程")]),e._v(" "),n("p",[e._v("在 "),n("code",[e._v("compilation.codeGeneration")]),e._v(" 执行完毕，即所有用户代码模块与运行时模块都执行完转译操作后，"),n("code",[e._v("seal")]),e._v(" 函数调用 "),n("code",[e._v("compilation.createChunkAssets")]),e._v(" 函数，触发 "),n("code",[e._v("renderManifest")]),e._v(" 钩子，"),n("code",[e._v("JavascriptModulesPlugin")]),e._v(" 插件监听到这个钩子消息后开始组装 bundle，伪代码：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('// Webpack 5\n// lib/Compilation.js\nclass Compilation {\n  seal() {\n    // 先把所有模块的代码都转译，准备好\n    this.codeGenerationResults = this.codeGeneration(this.modules);\n    // 1. 调用 createChunkAssets\n    this.createChunkAssets();\n  }\n\n  createChunkAssets() {\n    // 遍历 chunks ，为每个 chunk 执行 render 操作\n    for (const chunk of this.chunks) {\n      // 2. 触发 renderManifest 钩子\n      const res = this.hooks.renderManifest.call([], {\n        chunk,\n        codeGenerationResults: this.codeGenerationResults,\n        ...others,\n      });\n      // 提交组装结果\n      this.emitAsset(res.render(), ...others);\n    }\n  }\n}\n\n// lib/javascript/JavascriptModulesPlugin.js\nclass JavascriptModulesPlugin {\n  apply() {\n    compiler.hooks.compilation.tap("JavascriptModulesPlugin", (compilation) => {\n      compilation.hooks.renderManifest.tap("JavascriptModulesPlugin", (result, options) => {\n          // JavascriptModulesPlugin 插件中通过 renderManifest 钩子返回组装函数 render\n          const render = () =>\n            // render 内部根据 chunk 内容，选择使用模板 `renderMain` 或 `renderChunk`\n            // 3. 监听钩子，返回打包函数\n            this.renderMain(options);\n\n          result.push({ render /* arguments */ });\n          return result;\n        }\n      );\n    });\n  }\n\n  renderMain() {/*  */}\n\n  renderChunk() {/*  */}\n}\n')])])]),n("p",[e._v("这里的核心逻辑是，"),n("code",[e._v("compilation")]),e._v(" 以 "),n("code",[e._v("renderManifest")]),e._v(" 钩子方式对外发布 bundle 打包需求；"),n("code",[e._v("JavascriptModulesPlugin")]),e._v(" 监听这个钩子，按照 chunk 的内容特性，调用不同的打包函数。")]),e._v(" "),n("blockquote",[n("p",[e._v("上述仅针对 Webpack 5。在 Webpack 4 中，打包逻辑集中在 "),n("code",[e._v("MainTemplate")]),e._v(" 完成。")])]),e._v(" "),n("p",[n("code",[e._v("JavascriptModulesPlugin")]),e._v(" 内置的打包函数有：")]),e._v(" "),n("ul",[n("li",[n("code",[e._v("renderMain")]),e._v("：打包主 chunk 时使用")]),e._v(" "),n("li",[n("code",[e._v("renderChunk")]),e._v("：打包子 chunk ，如异步模块 chunk 时使用")])]),e._v(" "),n("p",[e._v("两个打包函数实现的逻辑接近，都是按顺序拼接各个模块，下面简单介绍下 "),n("code",[e._v("renderMain")]),e._v("的实现。")]),e._v(" "),n("h2",{attrs:{id:"_2-3-rendermain函数"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_2-3-rendermain函数"}},[e._v("#")]),e._v(" 2.3 "),n("code",[e._v("renderMain")]),e._v("函数")]),e._v(" "),n("p",[n("code",[e._v("renderMain")]),e._v(" 函数涉及比较多场景判断，原始代码很长很绕，我摘了几个重点步骤：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('class JavascriptModulesPlugin {\n  renderMain(renderContext, hooks, compilation) {\n    const { chunk, chunkGraph, runtimeTemplate } = renderContext;\n\n    const source = new ConcatSource();\n    // ...\n    // 1. 先计算出 bundle CMD 核心代码，包含：\n    //      - "var __webpack_module_cache__ = {};" 语句\n    //      - "__webpack_require__" 函数\n    const bootstrap = this.renderBootstrap(renderContext, hooks);\n\n    // 2. 计算出当前 chunk 下，除 entry 外其它模块的代码\n    const chunkModules = Template.renderChunkModules(\n      renderContext,\n      inlinedModules\n        ? allModules.filter((m) => !inlinedModules.has(m))\n        : allModules,\n      (module) =>\n        this.renderModule(\n          module,\n          renderContext,\n          hooks,\n          allStrict ? "strict" : true\n        ),\n      prefix\n    );\n\n    // 3. 计算出运行时模块代码\n    const runtimeModules =\n      renderContext.chunkGraph.getChunkRuntimeModulesInOrder(chunk);\n\n    // 4. 重点来了，开始拼接 bundle\n    // 4.1 首先，合并核心 CMD 实现，即上述 bootstrap 代码\n    const beforeStartup = Template.asString(bootstrap.beforeStartup) + "\\n";\n    source.add(\n      new PrefixSource(\n        prefix,\n        useSourceMap\n          ? new OriginalSource(beforeStartup, "webpack/before-startup")\n          : new RawSource(beforeStartup)\n      )\n    );\n\n    // 4.2 合并 runtime 模块代码\n    if (runtimeModules.length > 0) {\n      for (const module of runtimeModules) {\n        compilation.codeGeneratedModules.add(module);\n      }\n    }\n    // 4.3 合并除 entry 外其它模块代码\n    for (const m of chunkModules) {\n      const renderedModule = this.renderModule(m, renderContext, hooks, false);\n      source.add(renderedModule)\n    }\n\n    // 4.4 合并 entry 模块代码\n    if (\n      hasEntryModules &&\n      runtimeRequirements.has(RuntimeGlobals.returnExportsFromRuntime)\n    ) {\n      source.add(`${prefix}return __webpack_exports__;\\n`);\n    }\n\n    return source;\n  }\n}\n')])])]),n("p",[e._v("核心逻辑为：")]),e._v(" "),n("ul",[n("li",[n("p",[e._v("先计算出 bundle CMD 代码，即 "),n("code",[e._v("__webpack_require__")]),e._v(" 函数")])]),e._v(" "),n("li",[n("p",[e._v("计算出当前 chunk 下，除 entry 外其它模块代码 "),n("code",[e._v("chunkModules")])])]),e._v(" "),n("li",[n("p",[e._v("计算出运行时模块代码")])]),e._v(" "),n("li",[n("p",[e._v("开始执行合并操作，子步骤有：")])]),e._v(" "),n("li",[n("ul",[n("li",[e._v("合并 CMD 代码")]),e._v(" "),n("li",[e._v("合并 runtime 模块代码")]),e._v(" "),n("li",[e._v("遍历 "),n("code",[e._v("chunkModules")]),e._v(" 变量，合并除 entry 外其它模块代码")]),e._v(" "),n("li",[e._v("合并 entry 模块代码")])])]),e._v(" "),n("li",[n("p",[e._v("返回结果")])])]),e._v(" "),n("p",[e._v("总结：先计算出不同组成部分的产物形态，之后按顺序拼接打包，输出合并后的版本。")]),e._v(" "),n("p",[e._v("至此，Webpack 完成 bundle 的转译、打包流程，后续调用 "),n("code",[e._v("compilation.emitAsset")]),e._v(" ，按上下文环境将产物输出到 fs 即可，Webpack 单次编译打包过程就结束了。")]),e._v(" "),n("h1",{attrs:{id:"三、总结"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#三、总结"}},[e._v("#")]),e._v(" 三、总结")]),e._v(" "),n("p",[e._v("本文深入 Webpack 源码，详细讨论了打包流程后半截 —— 从 chunk graph 生成一直到最终输出产物的实现逻辑，重点：")]),e._v(" "),n("ul",[n("li",[e._v("首先遍历 chunk 中的所有模块，为每个模块执行转译操作，产出模块级别的产物")]),e._v(" "),n("li",[e._v("根据 chunk 的类型，选择不同结构框架，按序逐次组装模块产物，打包成最终 bundle")])]),e._v(" "),n("p",[e._v("回顾一下，我们：")]),e._v(" "),n("ul",[n("li",[e._v("在《["),n("a",{attrs:{href:"https://mp.weixin.qq.com/s?__biz=Mzg3OTYwMjcxMA==&mid=2247483744&idx=1&sn=d7128a76eed20746cd8c5100f0899138&scene=21#wechat_redirect",target:"_blank",rel:"noopener noreferrer"}},[e._v("万字总结] 一文吃透 Webpack 核心原理"),n("OutboundLink")],1),e._v("》中高度概括的讨论了 Webpack 从前到后的工作流程，帮助读者对 Webpack 的实现原理有一个较抽象的认知；")]),e._v(" "),n("li",[e._v("在《["),n("a",{attrs:{href:"https://mp.weixin.qq.com/s?__biz=Mzg3OTYwMjcxMA==&mid=2247483941&idx=1&sn=ce7597dfc8784e66d3c58f0e8df51f6b&scene=21#wechat_redirect",target:"_blank",rel:"noopener noreferrer"}},[e._v("源码解读] Webpack 插件架构深度讲解"),n("OutboundLink")],1),e._v("》详细介绍了 Webpack 插件机制的实现原理，帮助读者深入理解 Webpack 架构与钩子的设计；")]),e._v(" "),n("li",[e._v("在《"),n("a",{attrs:{href:"https://mp.weixin.qq.com/s?__biz=Mzg3OTYwMjcxMA==&mid=2247483743&idx=1&sn=0ce0845ee3e5316bcac05993035de3ed&scene=21#wechat_redirect",target:"_blank",rel:"noopener noreferrer"}},[e._v("有点难的 webpack 知识点：Dependency Graph 深度解析"),n("OutboundLink")],1),e._v("》详细介绍了语焉不详的 "),n("strong",[e._v("「模块依赖图」")]),e._v(" 概念，帮助读者理解 Webpack 中依赖发现与依赖关系构建过程")]),e._v(" "),n("li",[e._v("在《"),n("a",{attrs:{href:"https://mp.weixin.qq.com/s?__biz=Mzg3OTYwMjcxMA==&mid=2247484029&idx=1&sn=7862737524e799c5eaf1605325171e32&scene=21#wechat_redirect",target:"_blank",rel:"noopener noreferrer"}},[e._v("有点难的知识点：Webpack Chunk 分包规则详解"),n("OutboundLink")],1),e._v("》详细介绍了 chunk 分包的基本逻辑与实现方法，帮助读者理解产物分片的原理")]),e._v(" "),n("li",[e._v("在《"),n("a",{attrs:{href:"https://mp.weixin.qq.com/s?__biz=Mzg3OTYwMjcxMA==&mid=2247484088&idx=1&sn=41bf509a72f2cbcca1521747bf5e28f4&scene=21#wechat_redirect",target:"_blank",rel:"noopener noreferrer"}},[e._v("Webpack 原理系列六：彻底理解 Webpack 运行时"),n("OutboundLink")],1),e._v("》详细介绍了 bundle 中，除业务模块外其它运行时代码的由来与作用，帮助读者理解产物的运行逻辑")]),e._v(" "),n("li",[e._v("最后，再到本文介绍的模块转译与合并打包逻辑")])]),e._v(" "),n("p",[e._v("至此，Webpack 编译打包的主体流程已经能够很好地串联起来，相信读者沿着这条文章脉络，细心对照源码耐心学习，必定对前端的打包与工程化有一个深度的理解，互勉。")])])}),[],!1,null,null,null);n.default=a.exports}}]);
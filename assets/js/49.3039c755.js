(window.webpackJsonp=window.webpackJsonp||[]).push([[49],{341:function(e,a,t){"use strict";t.r(a);var s=t(4),r=Object(s.a)({},(function(){var e=this,a=e._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h1",{attrs:{id:"webpack-原理系列七-如何编写loader"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#webpack-原理系列七-如何编写loader"}},[e._v("#")]),e._v(" Webpack 原理系列七：如何编写loader")]),e._v(" "),a("p",[e._v("关于 Webpack Loader，网上已经有很多很多的资料，很难讲出花来，但是要写 Webpack 的系列博文又没办法绕开这一点，所以我阅读了超过 20 个开源项目，尽量全面地总结了一些编写 Loader 时需要了解的知识和技巧。包含：")]),e._v(" "),a("p",[a("img",{attrs:{src:"https://mmbiz.qpic.cn/mmbiz_png/3xDuJ3eicibll65ExluHjiagfEzNZxz4BjzR9QRkibqRD4E95upPjeLWibLkXGPD8k2ydOq6Ibccibn7ViaoegJrjQgQQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1",alt:"图片"}})]),e._v(" "),a("p",[e._v("那么，我们开始吧。")]),e._v(" "),a("h1",{attrs:{id:"认识-loader"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#认识-loader"}},[e._v("#")]),e._v(" 认识 Loader")]),e._v(" "),a("blockquote",[a("p",[e._v("❝")]),e._v(" "),a("p",[e._v("如果要做总结的话，我认为 Loader 是一个带有副作用的内容转译器！")]),e._v(" "),a("p",[e._v("❞")])]),e._v(" "),a("p",[e._v("Webpack Loader 最核心的只能是实现内容转换器 —— 将各式各样的资源转化为标准 JavaScript 内容格式，例如：")]),e._v(" "),a("ul",[a("li",[a("code",[e._v("css-loader")]),e._v(" 将 css 转换为 "),a("code",[e._v('__WEBPACK_DEFAULT_EXPORT__ = ".a{ xxx }"')]),e._v(" 格式")]),e._v(" "),a("li",[a("code",[e._v("html-loader")]),e._v(" 将 html 转换为 "),a("code",[e._v('__WEBPACK_DEFAULT_EXPORT__ = "<!DOCTYPE xxx"')]),e._v(" 格式")]),e._v(" "),a("li",[a("code",[e._v("vue-loader")]),e._v(" 更复杂一些，会将 "),a("code",[e._v(".vue")]),e._v(" 文件转化为多个 JavaScript 函数，分别对应 template、js、css、custom block")])]),e._v(" "),a("p",[e._v("那么为什么需要做这种转换呢？本质上是因为 Webpack 只认识符合 JavaScript 规范的文本(Webpack 5之后增加了其它 parser)：在构建(make)阶段，解析模块内容时会调用 "),a("code",[e._v("acorn")]),e._v("将文本转换为 AST 对象，进而分析代码结构，分析模块依赖；这一套逻辑对图片、json、Vue SFC等场景就不 work 了，就需要 Loader 介入将资源转化成 Webpack 可以理解的内容形态。")]),e._v(" "),a("blockquote",[a("p",[e._v("Plugin 是 Webpack 另一套扩展机制，功能更强，能够在各个对象的钩子中插入特化处理逻辑，它可以覆盖 Webpack 全生命流程，能力、灵活性、复杂度都会比 Loader 强很多，我们下次再讲。")])]),e._v(" "),a("h2",{attrs:{id:"loader-基础"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#loader-基础"}},[e._v("#")]),e._v(" Loader 基础")]),e._v(" "),a("p",[e._v("代码层面，Loader 通常是一个函数，结构如下：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("module.exports = function(source, sourceMap?, data?) {\n  // source 为 loader 的输入，可能是文件内容，也可能是上一个 loader 处理结果\n  return source;\n};\n")])])]),a("p",[e._v("Loader 函数接收三个参数，分别为：")]),e._v(" "),a("ul",[a("li",[a("code",[e._v("source")]),e._v("：资源输入，对于第一个执行的 loader 为资源文件的内容；后续执行的 loader 则为前一个 loader 的执行结果")]),e._v(" "),a("li",[a("code",[e._v("sourceMap")]),e._v(": 可选参数，代码的 sourcemap 结构")]),e._v(" "),a("li",[a("code",[e._v("data")]),e._v(": 可选参数，其它需要在 Loader 链中传递的信息，比如 posthtml/posthtml-loader 就会通过这个参数传递参数的 AST 对象")])]),e._v(" "),a("p",[e._v("其中 "),a("code",[e._v("source")]),e._v(" 是最重要的参数，大多数 Loader 要做的事情就是将 "),a("code",[e._v("source")]),e._v(" 转译为另一种形式的 "),a("code",[e._v("output")]),e._v(" ，比如 webpack-contrib/raw-loader 的核心源码：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("//... \nexport default function rawLoader(source) {\n  // ...\n\n  const json = JSON.stringify(source)\n    .replace(/\\u2028/g, '\\\\u2028')\n    .replace(/\\u2029/g, '\\\\u2029');\n\n  const esModule =\n    typeof options.esModule !== 'undefined' ? options.esModule : true;\n\n  return `${esModule ? 'export default' : 'module.exports ='} ${json};`;\n}\n")])])]),a("p",[e._v("这段代码的作用是将文本内容包裹成 JavaScript 模块，例如：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('// source\nI am Tecvan\n\n// output\nmodule.exports = "I am Tecvan"\n')])])]),a("p",[e._v("经过模块化包装之后，这段文本内容转身变成 Webpack 可以处理的资源模块，其它 module 也就能引用、使用它了。")]),e._v(" "),a("h2",{attrs:{id:"返回多个结果"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#返回多个结果"}},[e._v("#")]),e._v(" 返回多个结果")]),e._v(" "),a("p",[e._v("上例通过 "),a("code",[e._v("return")]),e._v(" 语句返回处理结果，除此之外 Loader 还可以以 "),a("code",[e._v("callback")]),e._v(" 方式返回更多信息，供下游 Loader 或者 Webpack 本身使用，例如在 webpack-contrib/eslint-loader 中：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("export default function loader(content, map) {\n  // ...\n  linter.printOutput(linter.lint(content));\n  this.callback(null, content, map);\n}\n")])])]),a("p",[e._v("通过 "),a("code",[e._v("this.callback(null, content, map)")]),e._v(" 语句同时返回转译后的内容与 sourcemap 内容。"),a("code",[e._v("callback")]),e._v(" 的完整签名如下：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("this.callback(\n    // 异常信息，Loader 正常运行时传递 null 值即可\n    err: Error | null,\n    // 转译结果\n    content: string | Buffer,\n    // 源码的 sourcemap 信息\n    sourceMap?: SourceMap,\n    // 任意需要在 Loader 间传递的值\n    // 经常用来传递 ast 对象，避免重复解析\n    data?: any\n);\n")])])]),a("h2",{attrs:{id:"异步处理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#异步处理"}},[e._v("#")]),e._v(" 异步处理")]),e._v(" "),a("p",[e._v("涉及到异步或 CPU 密集操作时，Loader 中还可以以异步形式返回处理结果，例如 webpack-contrib/less-loader 的核心逻辑：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('import less from "less";\n\nasync function lessLoader(source) {\n  // 1. 获取异步回调函数\n  const callback = this.async();\n  // ...\n\n  let result;\n\n  try {\n    // 2. 调用less 将模块内容转译为 css\n    result = await (options.implementation || less).render(data, lessOptions);\n  } catch (error) {\n    // ...\n  }\n\n  const { css, imports } = result;\n\n  // ...\n\n  // 3. 转译结束，返回结果\n  callback(null, css, map);\n}\n\nexport default lessLoader;\n')])])]),a("p",[e._v("在 less-loader 中，逻辑分三步：")]),e._v(" "),a("ul",[a("li",[e._v("调用 "),a("code",[e._v("this.async")]),e._v(" 获取异步回调函数，此时 Webpack 会将该 Loader 标记为异步加载器，会挂起当前执行队列直到 "),a("code",[e._v("callback")]),e._v(" 被触发")]),e._v(" "),a("li",[e._v("调用 "),a("code",[e._v("less")]),e._v(" 库将 less 资源转译为标准 css")]),e._v(" "),a("li",[e._v("调用异步回调 "),a("code",[e._v("callback")]),e._v(" 返回处理结果")])]),e._v(" "),a("p",[a("code",[e._v("this.async")]),e._v(" 返回的异步回调函数签名与上一节介绍的 "),a("code",[e._v("this.callback")]),e._v(" 相同，此处不再赘述。")]),e._v(" "),a("h2",{attrs:{id:"缓存"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#缓存"}},[e._v("#")]),e._v(" 缓存")]),e._v(" "),a("p",[e._v("Loader 为开发者提供了一种便捷的扩展方法，但在 Loader 中执行的各种资源内容转译操作通常都是 CPU 密集型 —— 这放在单线程的 Node 场景下可能导致性能问题；又或者异步 Loader 会挂起后续的加载器队列直到异步 Loader 触发回调，稍微不注意就可能导致整个加载器链条的执行时间过长。")]),e._v(" "),a("p",[e._v("为此，默认情况下 Webpack 会缓存 Loader 的执行结果直到资源或资源依赖发生变化，开发者需要对此有个基本的理解，必要时可以通过 "),a("code",[e._v("this.cachable")]),e._v(" 显式声明不作缓存，例如：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("module.exports = function(source) {\n  this.cacheable(false);\n  // ...\n  return output;\n};\n")])])]),a("h2",{attrs:{id:"上下文与-side-effect"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#上下文与-side-effect"}},[e._v("#")]),e._v(" 上下文与 Side Effect")]),e._v(" "),a("p",[e._v("除了作为内容转换器外，Loader 运行过程还可以通过一些上下文接口，有限制地影响 Webpack 编译过程，从而产生内容转换之外的副作用。")]),e._v(" "),a("p",[e._v("上下文信息可通过 "),a("code",[e._v("this")]),e._v(" 获取，"),a("code",[e._v("this")]),e._v(" 对象由 "),a("code",[e._v("NormolModule.createLoaderContext")]),e._v(" 函数在调用 Loader 前创建，常用的接口包括：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("const loaderContext = {\n    // 获取当前 Loader 的配置信息\n    getOptions: schema => {},\n    // 添加警告\n    emitWarning: warning => {},\n    // 添加错误信息，注意这不会中断 Webpack 运行\n    emitError: error => {},\n    // 解析资源文件的具体路径\n    resolve(context, request, callback) {},\n    // 直接提交文件，提交的文件不会经过后续的chunk、module处理，直接输出到 fs\n    emitFile: (name, content, sourceMap, assetInfo) => {},\n    // 添加额外的依赖文件\n    // watch 模式下，依赖文件发生变化时会触发资源重新编译\n    addDependency(dep) {},\n};\n")])])]),a("p",[e._v("其中，"),a("code",[e._v("addDependency")]),e._v("、"),a("code",[e._v("emitFile")]),e._v(" 、"),a("code",[e._v("emitError")]),e._v("、"),a("code",[e._v("emitWarning")]),e._v(" 都会对后续编译流程产生副作用，例如 "),a("code",[e._v("less-loader")]),e._v(" 中包含这样一段代码：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("  try {\n    result = await (options.implementation || less).render(data, lessOptions);\n  } catch (error) {\n    // ...\n  }\n\n  const { css, imports } = result;\n\n  imports.forEach((item) => {\n    // ...\n    this.addDependency(path.normalize(item));\n  });\n")])])]),a("p",[e._v("解释一下，代码中首先调用 "),a("code",[e._v("less")]),e._v(" 编译文件内容，之后遍历所有 "),a("code",[e._v("import")]),e._v(" 语句，也就是上例 "),a("code",[e._v("result.imports")]),e._v(" 数组，一一调用 "),a("code",[e._v("this.addDependency")]),e._v(" 函数将 import 到的其它资源都注册为依赖，之后这些其它资源文件发生变化时都会触发重新编译。")]),e._v(" "),a("h1",{attrs:{id:"loader-链式调用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#loader-链式调用"}},[e._v("#")]),e._v(" Loader 链式调用")]),e._v(" "),a("p",[e._v("使用上，可以为某种资源文件配置多个 Loader，Loader 之间按照配置的顺序从前到后(pitch)，再从后到前依次执行，从而形成一套内容转译工作流，例如对于下面的配置：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('module.exports = {\n  module: {\n    rules: [\n      {\n        test: /\\.less$/i,\n        use: [\n          "style-loader",\n          "css-loader",\n          "less-loader",\n        ],\n      },\n    ],\n  },\n};\n')])])]),a("p",[e._v("这是一个典型的 less 处理场景，针对 "),a("code",[e._v(".less")]),e._v(" 后缀的文件设定了：less、css、style 三个 loader 协作处理资源文件，按照定义的顺序，Webpack 解析 less 文件内容后先传入 less-loader；less-loader 返回的结果再传入 css-loader 处理；css-loader 的结果再传入 style-loader；最终以 style-loader 的处理结果为准，流程简化后如：")]),e._v(" "),a("p",[a("img",{attrs:{src:"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==",alt:"图片"}})]),e._v(" "),a("p",[e._v("上述示例中，三个 Loader 分别起如下作用：")]),e._v(" "),a("ul",[a("li",[a("code",[e._v("less-loader")]),e._v("：实现 less => css 的转换，输出 css 内容，无法被直接应用在 Webpack 体系下")]),e._v(" "),a("li",[a("code",[e._v("css-loader")]),e._v("：将 css 内容包装成类似 "),a("code",[e._v('module.exports = "${css}"')]),e._v(" 的内容，包装后的内容符合 JavaScript 语法")]),e._v(" "),a("li",[a("code",[e._v("style-loader")]),e._v("：做的事情非常简单，就是将 css 模块包进 require 语句，并在运行时调用 injectStyle 等函数将内容注入到页面的 style 标签")])]),e._v(" "),a("p",[e._v("三个 Loader 分别完成内容转化工作的一部分，形成从右到左的调用链条。链式调用这种设计有两个好处，一是保持单个 Loader 的单一职责，一定程度上降低代码的复杂度；二是细粒度的功能能够被组装成复杂而灵活的处理链条，提升单个 Loader 的可复用性。")]),e._v(" "),a("p",[e._v("不过，这只是链式调用的一部分，这里面有两个问题：")]),e._v(" "),a("ul",[a("li",[e._v("Loader 链条一旦启动之后，需要所有 Loader 都执行完毕才会结束，没有中断的机会 —— 除非显式抛出异常")]),e._v(" "),a("li",[e._v("某些场景下并不需要关心资源的具体内容，但 Loader 需要在 source 内容被读取出来之后才会执行")])]),e._v(" "),a("p",[e._v("为了解决这两个问题，Webpack 在 loader 基础上叠加了 "),a("code",[e._v("pitch")]),e._v(" 的概念。")]),e._v(" "),a("h1",{attrs:{id:"loader-pitch"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#loader-pitch"}},[e._v("#")]),e._v(" Loader Pitch")]),e._v(" "),a("p",[e._v("网络上关于 Loader 的文章已经有非常非常多，但多数并没有对 "),a("code",[e._v("pitch")]),e._v(" 这一重要特性做足够深入的介绍，没有讲清楚为什么要设计 pitch 这个功能，pitch 有哪些常见用例等。")]),e._v(" "),a("p",[e._v("在这一节，我会从 what、how、why 三个维度展开聊聊 loader pitch 这一特性。")]),e._v(" "),a("h2",{attrs:{id:"什么是-pitch"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#什么是-pitch"}},[e._v("#")]),e._v(" 什么是 pitch")]),e._v(" "),a("p",[e._v("Webpack 允许在这个函数上挂载名为 "),a("code",[e._v("pitch")]),e._v(" 的函数，运行时 pitch 会比 Loader 本身更早执行，例如：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("const loader = function (source){\n    console.log('后执行')\n    return source;\n}\n\nloader.pitch = function(requestString) {\n    console.log('先执行')\n}\n\nmodule.exports = loader\n")])])]),a("p",[e._v("Pitch 函数的完整签名：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("function pitch(\n    remainingRequest: string, previousRequest: string, data = {}\n): void {\n}\n")])])]),a("p",[e._v("包含三个参数：")]),e._v(" "),a("ul",[a("li",[a("code",[e._v("remainingRequest")]),e._v(" : 当前 loader 之后的资源请求字符串")]),e._v(" "),a("li",[a("code",[e._v("previousRequest")]),e._v(" : 在执行当前 loader 之前经历过的 loader 列表")]),e._v(" "),a("li",[a("code",[e._v("data")]),e._v(" : 与 Loader 函数的 "),a("code",[e._v("data")]),e._v(" 相同，用于传递需要在 Loader 传播的信息")])]),e._v(" "),a("p",[e._v("这些参数不复杂，但与 requestString 紧密相关，我们看个例子加深了解：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('module.exports = {\n  module: {\n    rules: [\n      {\n        test: /\\.less$/i,\n        use: [\n          "style-loader", "css-loader", "less-loader"\n        ],\n      },\n    ],\n  },\n};\n')])])]),a("p",[a("code",[e._v("css-loader.pitch")]),e._v(" 中拿到的参数依次为：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("// css-loader 之后的 loader 列表及资源路径\nremainingRequest = less-loader!./xxx.less\n// css-loader 之前的 loader 列表\npreviousRequest = style-loader\n// 默认值\ndata = {}\n")])])]),a("h2",{attrs:{id:"调度逻辑"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#调度逻辑"}},[e._v("#")]),e._v(" 调度逻辑")]),e._v(" "),a("p",[e._v("Pitch 翻译成中文是"),a("strong",[e._v("抛、球场、力度、事物最高点")]),e._v("等，我觉得 pitch 特性之所以被忽略完全是这个名字的锅，它背后折射的是一整套 Loader 被执行的生命周期概念。")]),e._v(" "),a("p",[e._v("实现上，Loader 链条执行过程分三个阶段：pitch、解析资源、执行，设计上与 DOM 的事件模型非常相似，pitch 对应到捕获阶段；执行对应到冒泡阶段；而两个阶段之间 Webpack 会执行资源内容的读取、解析操作，对应 DOM 事件模型的 AT_TARGET 阶段：")]),e._v(" "),a("p",[a("img",{attrs:{src:"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==",alt:"图片"}})]),e._v(" "),a("p",[a("code",[e._v("pitch")]),e._v(" 阶段按配置顺序从左到右逐个执行 "),a("code",[e._v("loader.pitch")]),e._v(" 函数(如果有的话)，开发者可以在 "),a("code",[e._v("pitch")]),e._v(" 返回任意值中断后续的链路的执行：")]),e._v(" "),a("p",[a("img",{attrs:{src:"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==",alt:"图片"}})]),e._v(" "),a("p",[e._v("那么为什么要设计 pitch 这一特性呢？在分析了 style-loader、vue-loader、to-string-loader 等开源项目之后，我个人总结出两个字："),a("strong",[e._v("「阻断」")]),e._v("！")]),e._v(" "),a("h2",{attrs:{id:"示例-style-loader"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#示例-style-loader"}},[e._v("#")]),e._v(" 示例：style-loader")]),e._v(" "),a("p",[e._v("先回顾一下前面提到过的 less 加载链条：")]),e._v(" "),a("ul",[a("li",[a("code",[e._v("less-loader")]),e._v(" ：将 less 规格的内容转换为标准 css")]),e._v(" "),a("li",[a("code",[e._v("css-loader")]),e._v(" ：将 css 内容包裹为 JavaScript 模块")]),e._v(" "),a("li",[a("code",[e._v("style-loader")]),e._v(" ：将 JavaScript 模块的导出结果以 "),a("code",[e._v("link")]),e._v(" 、"),a("code",[e._v("style")]),e._v(" 标签等方式挂载到 html 中，让 css 代码能够正确运行在浏览器上")])]),e._v(" "),a("p",[e._v("实际上， "),a("code",[e._v("style-loader")]),e._v(" 只是负责让 css 能够在浏览器环境下跑起来，本质上并不需要关心具体内容，很适合用 pitch 来处理，核心代码：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("// ...\n// Loader 本身不作任何处理\nconst loaderApi = () => {};\n\n// pitch 中根据参数拼接模块代码\nloaderApi.pitch = function loader(remainingRequest) {\n  //...\n\n  switch (injectType) {\n    case 'linkTag': {\n      return `${\n        esModule\n          ? `...`\n          // 引入 runtime 模块\n          : `var api = require(${loaderUtils.stringifyRequest(\n              this,\n              `!${path.join(__dirname, 'runtime/injectStylesIntoLinkTag.js')}`\n            )});\n            // 引入 css 模块\n            var content = require(${loaderUtils.stringifyRequest(\n              this,\n              `!!${remainingRequest}`\n            )});\n\n            content = content.__esModule ? content.default : content;`\n      } // ...`;\n    }\n\n    case 'lazyStyleTag':\n    case 'lazySingletonStyleTag': {\n        //...\n    }\n\n    case 'styleTag':\n    case 'singletonStyleTag':\n    default: {\n        // ...\n    }\n  }\n};\n\nexport default loaderApi;\n")])])]),a("p",[e._v("关键点：")]),e._v(" "),a("ul",[a("li",[a("p",[a("code",[e._v("loaderApi")]),e._v(" 为空函数，不做任何处理")])]),e._v(" "),a("li",[a("p",[a("code",[e._v("loaderApi.pitch")]),e._v(" 中拼接结果，导出的代码包含：")])]),e._v(" "),a("li",[a("ul",[a("li",[e._v("引入运行时模块 "),a("code",[e._v("runtime/injectStylesIntoLinkTag.js")])]),e._v(" "),a("li",[e._v("复用 "),a("code",[e._v("remainingRequest")]),e._v(" 参数，重新引入 css 文件")])])])]),e._v(" "),a("p",[e._v("运行结果大致如：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("var api = require('xxx/style-loader/lib/runtime/injectStylesIntoLinkTag.js')\nvar content = require('!!css-loader!less-loader!./xxx.less');\n")])])]),a("p",[e._v("注意了，到这里 style-loader 的 pitch 函数返回这一段内容，后续的 Loader 就不会继续执行，当前调用链条中断了：")]),e._v(" "),a("p",[a("img",{attrs:{src:"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==",alt:"图片"}})]),e._v(" "),a("p",[e._v("之后，Webpack 继续解析、构建 style-loader 返回的结果，遇到 inline loader 语句：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("var content = require('!!css-loader!less-loader!./xxx.less');\n")])])]),a("p",[e._v("所以从 Webpack 的角度看，实际上对同一个文件调用了两次 loader 链，第一次在 style-loader 的 pitch 中断，第二次根据 inline loader 的内容跳过了 style-loader。")]),e._v(" "),a("p",[e._v("相似的技巧在其它仓库也有出现，比如 vue-loader，感兴趣的同学可以查看我之前发在 ByteFE 公众号上的文章《"),a("a",{attrs:{href:"https://mp.weixin.qq.com/s?__biz=Mzg2ODQ1OTExOA==&mid=2247487730&idx=1&sn=0678ba3acebfd67ce4e31128d313c89b&scene=21#wechat_redirect",target:"_blank",rel:"noopener noreferrer"}},[e._v("Webpack 案例 ——vue-loader 原理分析"),a("OutboundLink")],1),e._v("》，这里就不展开讲了。")]),e._v(" "),a("h1",{attrs:{id:"进阶技巧"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#进阶技巧"}},[e._v("#")]),e._v(" 进阶技巧")]),e._v(" "),a("h2",{attrs:{id:"开发工具"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#开发工具"}},[e._v("#")]),e._v(" 开发工具")]),e._v(" "),a("p",[e._v("Webpack 为 Loader 开发者提供了两个实用工具，在诸多开源 Loader 中出现频率极高：")]),e._v(" "),a("ul",[a("li",[e._v("webpack/loader-utils：提供了一系列诸如读取配置、requestString 序列化与反序列化、计算 hash 值之类的工具函数")]),e._v(" "),a("li",[e._v("webpack/schema-utils：参数校验工具")])]),e._v(" "),a("p",[e._v("这些工具的具体接口在相应的 readme 上已经有明确的说明，不赘述，这里总结一些编写 Loader 时经常用到的样例：如何获取并校验用户配置；如何拼接输出文件名。")]),e._v(" "),a("h3",{attrs:{id:"获取并校验配置"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#获取并校验配置"}},[e._v("#")]),e._v(" 获取并校验配置")]),e._v(" "),a("p",[e._v("Loader 通常都提供了一些配置项，供开发者定制运行行为，用户可以通过 Webpack 配置文件的 "),a("code",[e._v("use.options")]),e._v(" 属性设定配置，例如：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('module.exports = {\n  module: {\n    rules: [{\n      test: /\\.less$/i,\n      use: [\n        {\n          loader: "less-loader",\n          options: {\n            cacheDirectory: false\n          }\n        },\n      ],\n    }],\n  },\n};\n')])])]),a("p",[e._v("在 Loader 内部，需要使用 "),a("code",[e._v("loader-utils")]),e._v(" 库的 "),a("code",[e._v("getOptions")]),e._v(" 函数获取用户配置，用 "),a("code",[e._v("schema-utils")]),e._v(" 库的 "),a("code",[e._v("validate")]),e._v(" 函数校验参数合法性，例如 css-loader：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('// css-loader/src/index.js\nimport { getOptions } from "loader-utils";\nimport { validate } from "schema-utils";\nimport schema from "./options.json";\n\n\nexport default async function loader(content, map, meta) {\n  const rawOptions = getOptions(this);\n\n  validate(schema, rawOptions, {\n    name: "CSS Loader",\n    baseDataPath: "options",\n  });\n  // ...\n}\n')])])]),a("p",[e._v("使用 "),a("code",[e._v("schema-utils")]),e._v(" 做校验时需要提前声明配置模板，通常会处理成一个额外的 json 文件，例如上例中的 "),a("code",[e._v('"./options.json"')]),e._v("。")]),e._v(" "),a("h3",{attrs:{id:"拼接输出文件名"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#拼接输出文件名"}},[e._v("#")]),e._v(" 拼接输出文件名")]),e._v(" "),a("p",[e._v("Webpack 支持以类似 "),a("code",[e._v("[path]/[name]-[hash].js")]),e._v(" 方式设定 "),a("code",[e._v("output.filename")]),e._v("即输出文件的命名，这一层规则通常不需要关注，但某些场景例如 webpack-contrib/file-loader 需要根据 asset 的文件名拼接结果。")]),e._v(" "),a("p",[a("code",[e._v("file-loader")]),e._v(" 支持在 JS 模块中引入诸如 png、jpg、svg 等文本或二进制文件，并将文件写出到输出目录，这里面有一个问题：假如文件叫 "),a("code",[e._v("a.jpg")]),e._v(" ，经过 Webpack 处理后输出为 "),a("code",[e._v("[hash].jpg")]),e._v(" ，怎么对应上呢？此时就可以使用 "),a("code",[e._v("loader-utils")]),e._v(" 提供的 "),a("code",[e._v("interpolateName")]),e._v(" 在 "),a("code",[e._v("file-loader")]),e._v(" 中获取资源写出的路径及名称，源码：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("import { getOptions, interpolateName } from 'loader-utils';\n\nexport default function loader(content) {\n  const context = options.context || this.rootContext;\n  const name = options.name || '[contenthash].[ext]';\n\n  // 拼接最终输出的名称\n  const url = interpolateName(this, name, {\n    context,\n    content,\n    regExp: options.regExp,\n  });\n\n  let outputPath = url;\n  // ...\n\n  let publicPath = `__webpack_public_path__ + ${JSON.stringify(outputPath)}`;\n  // ...\n\n  if (typeof options.emitFile === 'undefined' || options.emitFile) {\n    // ...\n\n    // 提交、写出文件\n    this.emitFile(outputPath, content, null, assetInfo);\n  }\n  // ...\n\n  const esModule =\n    typeof options.esModule !== 'undefined' ? options.esModule : true;\n\n  // 返回模块化内容\n  return `${esModule ? 'export default' : 'module.exports ='} ${publicPath};`;\n}\n\nexport const raw = true;\n")])])]),a("p",[e._v("代码的核心逻辑：")]),e._v(" "),a("ol",[a("li",[e._v("根据 Loader 配置，调用 "),a("code",[e._v("interpolateName")]),e._v(" 方法拼接目标文件的完整路径")]),e._v(" "),a("li",[e._v("调用上下文 "),a("code",[e._v("this.emitFile")]),e._v(" 接口，写出文件")]),e._v(" "),a("li",[e._v("返回 "),a("code",[e._v("module.exports = ${publicPath}")]),e._v(" ，其它模块可以引用到该文件路径")])]),e._v(" "),a("p",[e._v("除 file-loader 外，css-loader、eslint-loader 都有用到该接口，感兴趣的同学请自行前往查阅源码。")]),e._v(" "),a("h2",{attrs:{id:"单元测试"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#单元测试"}},[e._v("#")]),e._v(" 单元测试")]),e._v(" "),a("p",[e._v("在 Loader 中编写单元测试收益非常高，一方面对开发者来说不用去怎么写 demo，怎么搭建测试环境；一方面对于最终用户来说，带有一定测试覆盖率的项目通常意味着更高、更稳定的质量。")]),e._v(" "),a("p",[e._v("阅读了超过 20 个开源项目后，我总结了一套 Webpack Loader 场景下常用的单元测试流程，以 Jest · 🃏 Delightful JavaScript Testing 为例：")]),e._v(" "),a("ol",[a("li",[e._v("创建在 Webpack 实例，并运行 Loader")]),e._v(" "),a("li",[e._v("获取 Loader 执行结果，比对、分析判断是否符合预期")]),e._v(" "),a("li",[e._v("判断执行过程中是否出错")])]),e._v(" "),a("h3",{attrs:{id:"如何运行-loader"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#如何运行-loader"}},[e._v("#")]),e._v(" 如何运行 Loader")]),e._v(" "),a("p",[e._v("有两种办法，一是在 node 环境下运行调用 Webpack 接口，用代码而非命令行执行编译，很多框架都会采用这种方式，例如 vue-loader、stylus-loader、babel-loader 等，优点的运行效果最接近最终用户，缺点是运行效率相对较低(可以忽略)。")]),e._v(" "),a("p",[e._v("以 posthtml/posthtml-loader 为例，它会在启动测试之前创建并运行 Webpack 实例：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("// posthtml-loader/test/helpers/compiler.js 文件\nmodule.exports = function (fixture, config, options) {\n  config = { /*...*/ }\n\n  options = Object.assign({ output: false }, options)\n\n  // 创建 Webpack 实例\n  const compiler = webpack(config)\n\n  // 以 MemoryFS 方式输出构建结果，避免写磁盘\n  if (!options.output) compiler.outputFileSystem = new MemoryFS()\n\n  // 执行，并以 promise 方式返回结果\n  return new Promise((resolve, reject) => compiler.run((err, stats) => {\n    if (err) reject(err)\n    // 异步返回执行结果\n    resolve(stats)\n  }))\n}\n")])])]),a("blockquote",[a("p",[e._v("小技巧：如上例所示，用 "),a("code",[e._v("compiler.outputFileSystem = new MemoryFS()")]),e._v("语句将 Webpack 设定成输出到内存，能避免写盘操作，提升编译速度。")])]),e._v(" "),a("p",[e._v("另外一种方法是编写一系列 mock 方法，搭建起一个模拟的 Webpack 运行环境，例如 emaphp/underscore-template-loader ，优点的运行速度更快，缺点是开发工作量大通用性低，了解了解即可。")]),e._v(" "),a("h3",{attrs:{id:"比对结果"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#比对结果"}},[e._v("#")]),e._v(" 比对结果")]),e._v(" "),a("p",[e._v("上例运行结束之后会以 "),a("code",[e._v("resolve(stats)")]),e._v(" 方式返回执行结果，"),a("code",[e._v("stats")]),e._v(" 对象中几乎包含了编译过程所有信息，包括耗时、产物、模块、chunks、errors、warnings 等等，我在之前的文章 "),a("a",{attrs:{href:"https://mp.weixin.qq.com/s?__biz=Mzg3OTYwMjcxMA==&mid=2247484005&idx=1&sn=ae3e478259a50c54e0282b2efbc28c3f&scene=21#wechat_redirect",target:"_blank",rel:"noopener noreferrer"}},[e._v("分享几个 Webpack 实用分析工具"),a("OutboundLink")],1),e._v(" 对此已经做了较深入的介绍，感兴趣的同学可以前往阅读。")]),e._v(" "),a("p",[e._v("在测试场景下，可以从 "),a("code",[e._v("stats")]),e._v(" 对象中读取编译最终输出的产物，例如 style-loader 的实现：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("// style-loader/src/test/helpers/readAsset.js 文件\nfunction readAsset(compiler, stats, assets) => {\n  const usedFs = compiler.outputFileSystem\n  const outputPath = stats.compilation.outputOptions.path\n  const queryStringIdx = targetFile.indexOf('?')\n\n  if (queryStringIdx >= 0) {\n    // 解析出输出文件路径\n    asset = asset.substr(0, queryStringIdx)\n  }\n\n  // 读文件内容\n  return usedFs.readFileSync(path.join(outputPath, targetFile)).toString()\n}\n")])])]),a("p",[e._v("解释一下，这段代码首先计算 asset 输出的文件路径，之后调用 outputFileSystem 的 "),a("code",[e._v("readFile")]),e._v(" 方法读取文件内容。")]),e._v(" "),a("p",[e._v("接下来，有两种分析内容的方法：")]),e._v(" "),a("ul",[a("li",[e._v("调用 Jest 的 "),a("code",[e._v("expect(xxx).toMatchSnapshot()")]),e._v(" 断言判断当前运行结果是否与之前的运行结果一致，从而确保多次修改的结果一致性，很多框架都大量用了这种方法")]),e._v(" "),a("li",[e._v("解读资源内容，判断是否符合预期，例如 less-loader 的单元测试中会对同一份代码跑两次 less 编译，一次由 Webpack 执行，一次直接调用 "),a("code",[e._v("less")]),e._v(" 库，之后分析两次运行结果是否相同")])]),e._v(" "),a("p",[e._v("对此有兴趣的同学，强烈建议看看 "),a("code",[e._v("less-loader")]),e._v(" 的 test 目录。")]),e._v(" "),a("h3",{attrs:{id:"异常判断"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#异常判断"}},[e._v("#")]),e._v(" 异常判断")]),e._v(" "),a("p",[e._v("最后，还需要判断编译过程是否出现异常，同样可以从 "),a("code",[e._v("stats")]),e._v(" 对象解析：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("export default getErrors = (stats) => {\n  const errors = stats.compilation.errors.sort()\n  return errors.map(\n    e => e.toString()\n  )\n}\n")])])]),a("p",[e._v("大多数情况下都希望编译没有错误，此时只要判断结果数组是否为空即可。某些情况下可能需要判断是否抛出特定异常，此时可以 "),a("code",[e._v("expect(xxx).toMatchSnapshot()")]),e._v(" 断言，用快照对比更新前后的结果。")]),e._v(" "),a("h2",{attrs:{id:"调试"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#调试"}},[e._v("#")]),e._v(" 调试")]),e._v(" "),a("p",[e._v("开发 Loader 的过程中，有一些小技巧能够提升调试效率，包括：")]),e._v(" "),a("ul",[a("li",[e._v("使用 ndb 工具实现断点调试")]),e._v(" "),a("li",[e._v("使用 "),a("code",[e._v("npm link")]),e._v(" 将 Loader 模块链接到测试项目")]),e._v(" "),a("li",[e._v("使用 "),a("code",[e._v("resolveLoader")]),e._v(" 配置项将 Loader 所在的目录加入到测试项目中，如：")])]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("// webpack.config.js\nmodule.exports = {\n  resolveLoader:{\n    modules: ['node_modules','./loaders/'],\n  }\n}\n")])])]),a("h1",{attrs:{id:"无关紧要总结"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#无关紧要总结"}},[e._v("#")]),e._v(" 无关紧要总结")]),e._v(" "),a("p",[e._v("这是 Webpack 原理分析系列第七篇文章，说实话最开始并没有想到能写这么多，后续还会继续 focus 在这个前端工程化领域，我的目标是能攒成一本自己的书，感兴趣的同学欢迎点赞关注，如果觉得有什么地方遗漏、疑惑，欢迎评论讨论。")]),e._v(" "),a("p",[a("img",{attrs:{src:"http://mmbiz.qpic.cn/mmbiz_png/3xDuJ3eiciblkrkIk3XeyL1jc2o7J5FUibbjapRDRicM4S9rFHhoJFK8EBW9SWf8CPO8pSSanB9oo3dD4VPThlbeeA/0?wx_fmt=png",alt:"Tecvan"}})]),e._v(" "),a("p",[a("strong",[e._v("Tecvan")])]),e._v(" "),a("p",[e._v("专注前端框架源码解读")]),e._v(" "),a("p",[e._v("18篇原创内容")]),e._v(" "),a("p",[e._v("公众号")]),e._v(" "),a("blockquote",[a("p",[e._v("往期文章")]),e._v(" "),a("ul",[a("li",[a("a",{attrs:{href:"https://mp.weixin.qq.com/s?__biz=Mzg3OTYwMjcxMA==&mid=2247484005&idx=1&sn=ae3e478259a50c54e0282b2efbc28c3f&scene=21#wechat_redirect",target:"_blank",rel:"noopener noreferrer"}},[e._v("分享几个 Webpack 实用分析工具"),a("OutboundLink")],1)]),e._v(" "),a("li",[e._v("[建议收藏] Webpack 4+ 优秀学习资料合集")]),e._v(" "),a("li",[e._v("["),a("a",{attrs:{href:"https://mp.weixin.qq.com/s?__biz=Mzg3OTYwMjcxMA==&mid=2247483744&idx=1&sn=d7128a76eed20746cd8c5100f0899138&scene=21#wechat_redirect",target:"_blank",rel:"noopener noreferrer"}},[e._v("万字总结] 一文吃透 Webpack 核心原理"),a("OutboundLink")],1)]),e._v(" "),a("li",[e._v("["),a("a",{attrs:{href:"https://mp.weixin.qq.com/s?__biz=Mzg3OTYwMjcxMA==&mid=2247483941&idx=1&sn=ce7597dfc8784e66d3c58f0e8df51f6b&scene=21#wechat_redirect",target:"_blank",rel:"noopener noreferrer"}},[e._v("源码解读] Webpack 插件架构深度讲解"),a("OutboundLink")],1)]),e._v(" "),a("li",[a("a",{attrs:{href:"https://mp.weixin.qq.com/s?__biz=Mzg3OTYwMjcxMA==&mid=2247483956&idx=1&sn=a2066fcc76cd97de88a6d6cb397e6c2a&scene=21#wechat_redirect",target:"_blank",rel:"noopener noreferrer"}},[e._v("十分钟精进 Webpack：module.issuer 属性详解"),a("OutboundLink")],1)]),e._v(" "),a("li",[a("a",{attrs:{href:"https://mp.weixin.qq.com/s?__biz=Mzg3OTYwMjcxMA==&mid=2247483743&idx=1&sn=0ce0845ee3e5316bcac05993035de3ed&scene=21#wechat_redirect",target:"_blank",rel:"noopener noreferrer"}},[e._v("有点难的 webpack 知识点：Dependency Graph 深度解析"),a("OutboundLink")],1)]),e._v(" "),a("li",[a("a",{attrs:{href:"https://mp.weixin.qq.com/s?__biz=Mzg3OTYwMjcxMA==&mid=2247484029&idx=1&sn=7862737524e799c5eaf1605325171e32&scene=21#wechat_redirect",target:"_blank",rel:"noopener noreferrer"}},[e._v("有点难的知识点：Webpack Chunk 分包规则详解"),a("OutboundLink")],1)]),e._v(" "),a("li",[a("a",{attrs:{href:"https://mp.weixin.qq.com/s?__biz=Mzg3OTYwMjcxMA==&mid=2247484088&idx=1&sn=41bf509a72f2cbcca1521747bf5e28f4&scene=21#wechat_redirect",target:"_blank",rel:"noopener noreferrer"}},[e._v("Webpack 原理系列六：彻底理解 Webpack 运行时"),a("OutboundLink")],1)])])])])}),[],!1,null,null,null);a.default=r.exports}}]);
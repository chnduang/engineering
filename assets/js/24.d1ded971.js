(window.webpackJsonp=window.webpackJsonp||[]).push([[24],{316:function(e,t,a){"use strict";a.r(t);var n=a(4),o=Object(n.a)({},(function(){var e=this,t=e._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"这次一定学会babel插件开发"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#这次一定学会babel插件开发"}},[e._v("#")]),e._v(" 这次一定学会babel插件开发！")]),e._v(" "),t("blockquote",[t("p",[t("a",{attrs:{href:"https://mp.weixin.qq.com/s/7NVq_P7SC2YOHYs_TjAbQQ",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://mp.weixin.qq.com/s/7NVq_P7SC2YOHYs_TjAbQQ"),t("OutboundLink")],1)])]),e._v(" "),t("h1",{attrs:{id:"前置知识"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#前置知识"}},[e._v("#")]),e._v(" 前置知识")]),e._v(" "),t("h2",{attrs:{id:"什么是ast"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#什么是ast"}},[e._v("#")]),e._v(" 什么是AST")]),e._v(" "),t("p",[e._v("学习babel, 必备知识就是理解AST。")]),e._v(" "),t("p",[t("strong",[e._v("那什么是AST呢？")])]),e._v(" "),t("p",[e._v("先来看下维基百科的解释:")]),e._v(" "),t("blockquote",[t("p",[e._v("在计算机科学中，抽象语法树（Abstract Syntax Tree，AST），或简称语法树（Syntax tree），是源代码语法结构的一种抽象表示。它以树状的形式表现编程语言的语法结构，树上的每个节点都表示源代码中的一种结构")])]),e._v(" "),t("p",[e._v('"'),t("code",[e._v("源代码语法结构的一种抽象表示")]),e._v('" 这几个字要划重点，是我们理解AST的关键，说人话就是按照某种约定好的规范，以树形的数据结构把我们的代码描述出来，让js引擎和转译器能够理解。')]),e._v(" "),t("p",[e._v("举个例子：就好比现在框架会利用"),t("code",[e._v("虚拟dom")]),e._v("这种方式把"),t("code",[e._v("真实dom")]),e._v("结构描述出来再进行操作一样，而对于更底层的代码来说，AST就是用来描述代码的好工具。")]),e._v(" "),t("p",[e._v("当然AST不是JS特有的，每个语言的代码都能转换成对应的AST, 并且AST结构的规范也有很多， js里所使用的规范大部分是 "),t("strong",[e._v("estree")]),e._v("[1] ，当然这个只做简单了解即可。")]),e._v(" "),t("h2",{attrs:{id:"ast到底长啥样"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#ast到底长啥样"}},[e._v("#")]),e._v(" AST到底长啥样")]),e._v(" "),t("p",[e._v("了解了AST的基本概念， 那AST到底长啥样呢？")]),e._v(" "),t("p",[t("strong",[e._v("astexplorer.net")]),e._v("[2]这个网站可以在线生成AST, 我们可以在里面进行尝试生成AST，用来学习一下结构")]),e._v(" "),t("h2",{attrs:{id:"babel的处理过程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#babel的处理过程"}},[e._v("#")]),e._v(" babel的处理过程")]),e._v(" "),t("p",[t("em",[e._v("问：把冰箱塞进大象有几个阶段？")])]),e._v(" "),t("p",[t("em",[e._v("打开冰箱 -> 塞进大象 -> 关上冰箱")])]),e._v(" "),t("p",[e._v("babel也是如此，babel利用AST的方式对代码进行编译，首先自然是需要将代码变为AST，再对AST进行处理，处理完以后呢再将AST 转换回来")]),e._v(" "),t("p",[e._v("也就是如下的流程")]),e._v(" "),t("blockquote",[t("p",[t("em",[e._v("code转换为AST -> 处理AST -> AST转换为code")])])]),e._v(" "),t("p",[e._v("然后我们再给它们一个专业一点的名字")]),e._v(" "),t("blockquote",[t("p",[t("em",[e._v("解析 -> 转换 -> 生成")])])]),e._v(" "),t("h3",{attrs:{id:"解析-parse"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#解析-parse"}},[e._v("#")]),e._v(" 解析（parse）")]),e._v(" "),t("blockquote",[t("p",[e._v("通过 parser 把源码转成抽象语法树（AST）")])]),e._v(" "),t("p",[e._v("这个阶段的主要任务就是将code转为AST, 其中会经过两个阶段，分别是词法分析和语法分析。当parse阶段开始时，首先会进行文档扫描，并在此期间进行词法分析。那怎么理解此法分析呢 如果把我们所写的一段code比喻成句子，词法分析所做的事情就是在拆分这个句子。如同 "),t("code",[e._v("“我正在吃饭”")]),e._v(" 这句话，可以被拆解为"),t("code",[e._v("“我”")]),e._v("、"),t("code",[e._v("“正在”")]),e._v("、"),t("code",[e._v("“吃饭”")]),e._v("一样, code也是如此。比如: const a = '1' 会被拆解为一个个最细粒度的单词(tokon): 'const', 'a', '=', '1' 这就是词法分析阶段所做的事情。")]),e._v(" "),t("p",[e._v("词法分析结束后，将分析所得到的 tokens 交给语法分析， 语法分析阶段的任务就是根据 tokens 生成 AST。它会对 tokens 进行遍历，最终按照特定的结构生成一个 tree 这个 tree 就是 AST。")]),e._v(" "),t("p",[e._v("如下图, 可以看到上面语句的到的结构，我们找到了几个重要信息, 最外层是一个"),t("code",[e._v("VariableDeclaration")]),e._v("意思是变量声明，所使用的类型是 "),t("code",[e._v("const")]),e._v(", 字段"),t("code",[e._v("declarations")]),e._v("内还有一个 "),t("code",[e._v("VariableDeclarator")]),e._v("[变量声明符] 对象，找到了 "),t("code",[e._v("a")]),e._v(", "),t("code",[e._v("1")]),e._v(" 两个关键字。"),t("img",{attrs:{src:"https://mmbiz.qpic.cn/mmbiz/pfCCZhlbMQRR1x1btjbliaibhknJlowibugib50rqaC7ZLZV44JEyzuibOhXERicJmToQdibeeyHFyjjOxiaLUqWyibDvkg/640?wx_fmt=other&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1",alt:"图片"}})]),e._v(" "),t("p",[e._v("除了这些关键字以为，还可以找到例如行号等等的重要信息，这里就不一一展开阐述。总之，这就是我们最终得到的 AST 模样。")]),e._v(" "),t("p",[e._v("那问题来了，babel里该如何将code 转为 AST 呢？在这个阶段我们会用到 babel 提供的解析器 @babel/parser，之前叫 Babylon，它并非由babel团队自己开发的，而是基于fork的 acorn 项目。")]),e._v(" "),t("p",[e._v("它为我们提供了将code转换为AST的方法，基本用法如下:")]),e._v(" "),t("p",[t("img",{attrs:{src:"https://mmbiz.qpic.cn/mmbiz/pfCCZhlbMQRR1x1btjbliaibhknJlowibugjuaIN6qQCmpiapNj7GtiaLd5w6FXNWzFibKBibMN2ibdWuYhDSzFZ8sNKZw/640?wx_fmt=other&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1",alt:"图片"}}),e._v("file")]),e._v(" "),t("p",[e._v("更多信息可以访问官方文档查看**@babel/parser**[3]")]),e._v(" "),t("h3",{attrs:{id:"转换-transform"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#转换-transform"}},[e._v("#")]),e._v(" 转换（transform）")]),e._v(" "),t("p",[e._v("在 parse 阶段后，我们已经成功得到了AST。babel接收到 AST后，会使用 @babel/traverse 对其进行深度优先遍历，插件会在这个阶段被触发，以vistor 函数的形式访问每种不同类型的AST节点。以上面代码为例, 我们可以编写 "),t("code",[e._v("VariableDeclaration")]),e._v(" 函数对 "),t("code",[e._v("VariableDeclaration")]),e._v("节点进行访问，每当遇到该类型节点时都会触发该方法。如下：")]),e._v(" "),t("p",[t("img",{attrs:{src:"https://mmbiz.qpic.cn/mmbiz/pfCCZhlbMQRR1x1btjbliaibhknJlowibuga0nLW9ibEFl8FoebcL7lvP3k9MptpiafcfymVJCEkZZYBB1XicuicqzlYA/640?wx_fmt=other&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1",alt:"图片"}}),e._v("file")]),e._v(" "),t("p",[e._v("该方法接受两个参数，")]),e._v(" "),t("h4",{attrs:{id:"path"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#path"}},[e._v("#")]),e._v(" path")]),e._v(" "),t("p",[e._v("path为当前访问的路径, 并且包含了节点的信息、父节点信息以及对节点操作许多方法。可以利用这些方法对 ATS 进行添加、更新、移动和删除等等。")]),e._v(" "),t("h4",{attrs:{id:"state"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#state"}},[e._v("#")]),e._v(" state")]),e._v(" "),t("p",[e._v("state包含了当前plugin的信息和参数信息等等，并且也可以用来自定义在节点之间传递数据。")]),e._v(" "),t("h3",{attrs:{id:"生成-generate"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#生成-generate"}},[e._v("#")]),e._v(" 生成（generate）")]),e._v(" "),t("p",[e._v("generate：把转换后的 AST 打印成目标代码，并生成 sourcemap")]),e._v(" "),t("p",[e._v("这个阶段就比较简单了， 在 transform 阶段处理 AST 结束后，该阶段的任务就是将 AST 转换回 code, 在此期间会对 AST 进行深度优先遍历，根据节点所包含的信息生成对应的代码，并且会生成对应的sourcemap。")]),e._v(" "),t("h2",{attrs:{id:"经典案例尝试"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#经典案例尝试"}},[e._v("#")]),e._v(" 经典案例尝试")]),e._v(" "),t("p",[e._v("俗话说，最好的学习就是动手，我们来一起尝试一个简单的经典案例：将上面案例中的 es6 的 "),t("code",[e._v("const")]),e._v(" 转变为 es5 的 "),t("code",[e._v("var")])]),e._v(" "),t("h3",{attrs:{id:"第一步-转换为-ast"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#第一步-转换为-ast"}},[e._v("#")]),e._v(" 第一步: 转换为 AST")]),e._v(" "),t("p",[e._v("使用 "),t("code",[e._v("@babel/parser")]),e._v(" 生成AST\n比较简单，跟上面的案例是一样的， 此时我们ast变量中就是转换后的 AST")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("const parser = require('@babel/parser');\nconst ast = parser.parse('const a = 1');\n复制代码\n")])])]),t("h3",{attrs:{id:"第二步-处理-ast"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#第二步-处理-ast"}},[e._v("#")]),e._v(" 第二步：处理 AST")]),e._v(" "),t("p",[e._v("使用 "),t("code",[e._v("@babel/traverse")]),e._v(" 处理 AST")]),e._v(" "),t("p",[e._v("在这个阶段我们通过分析所生成的 AST 结构，确定了在 "),t("code",[e._v("VariableDeclaration")]),e._v(" 中由 "),t("code",[e._v("kind")]),e._v(" 字段控制 "),t("code",[e._v("const")]),e._v("，所以我们是不是可以尝试着把 "),t("code",[e._v("kind")]),e._v(" 改写成我们想要的 "),t("code",[e._v("var")]),e._v(" ？既然如此，我们来尝试一下")]),e._v(" "),t("p",[t("img",{attrs:{src:"https://mmbiz.qpic.cn/mmbiz/pfCCZhlbMQRR1x1btjbliaibhknJlowibugib50rqaC7ZLZV44JEyzuibOhXERicJmToQdibeeyHFyjjOxiaLUqWyibDvkg/640?wx_fmt=other&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1",alt:"图片"}}),e._v("file")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("const parser = require('@babel/parser');\nconst traverse = require('@babel/traverse').default\n\nconst ast = parser.parse('const a = 1');\ntraverse(ast, {\n    VariableDeclaration(path, state) {\n   // 通过 path.node 访问实际的 AST 节点\n      path.node.kind = 'var'\n    }\n});\n复制代码\n")])])]),t("p",[e._v("好，此时我们凭借着猜想修改了 "),t("code",[e._v("kind")]),e._v(" ，将其改写为了 "),t("code",[e._v("var")]),e._v(", 但是我们还不能知道实际是否有效，所以我们需要将其再转换回 code 看看效果。")]),e._v(" "),t("h3",{attrs:{id:"第三步-生成-code"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#第三步-生成-code"}},[e._v("#")]),e._v(" 第三步：生成 code")]),e._v(" "),t("p",[e._v("使用 "),t("code",[e._v("@babel/generator")]),e._v(" 处理 AST")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("const parser = require('@babel/parser');\nconst traverse = require('@babel/traverse').default\nconst generate = require('@babel/generator').default\n\nconst ast = parser.parse('const a = 1');\ntraverse(ast, {\n    VariableDeclaration(path, state) {\n      path.node.kind = 'var'\n    }\n});\n\n// 将处理好的 AST 放入 generate\nconst transformedCode = generate(ast).code\nconsole.log(transformedCode)\n复制代码\n")])])]),t("p",[e._v("我们再来看看效果：")]),e._v(" "),t("p",[t("img",{attrs:{src:"https://mmbiz.qpic.cn/mmbiz/pfCCZhlbMQRR1x1btjbliaibhknJlowibug3vTAZzDfh3R1icWN2wNazOPiciafY4Px5C2yWe0cYtZ6puvakI4Xa3wicg/640?wx_fmt=other&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1",alt:"图片"}}),e._v("file")]),e._v(" "),t("p",[e._v("执行完成，成功了，是我们想要的效果～")]),e._v(" "),t("h2",{attrs:{id:"如何开发插件"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#如何开发插件"}},[e._v("#")]),e._v(" 如何开发插件")]),e._v(" "),t("p",[e._v("通过上面这个经典案例， 大概了解了 babel 的使用，但我们平时的插件该如何去写呢？")]),e._v(" "),t("p",[e._v("实际上插件的开发和上面的基本思路是一样的， 只是作为插件我们只需要关注这其中的 "),t("code",[e._v("转换")]),e._v(" 阶段")]),e._v(" "),t("p",[e._v("我们的插件需要导出一个函数/对象， 如果是函数则需要返回一个对象, 我们只需要在改对象的 visitor 内做同样的事情即可，并且函数会接受几个参数， api继承了babel提供的一系列方法， options 是我们使用插件时所传递的参数，dirname 为处理时期的文件路径。")]),e._v(" "),t("p",[e._v("以上面的案例改造为如下：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("module.exports = {\n visitor: {\n     VariableDeclaration(path, state) {\n          path.node.kind = 'var'\n        }\n }\n}\n// 或是函数形式\nmodule.exports = (api, options, dirname) => {\n return {\n  visitor: {\n          VariableDeclaration(path, state) {\n            path.node.kind = 'var'\n          }\n  }\n }\n}\n复制代码\n")])])]),t("h1",{attrs:{id:"插件编写"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#插件编写"}},[e._v("#")]),e._v(" 插件编写")]),e._v(" "),t("p",[e._v("在有前置知识的基础上，我们来一步步的讲解开发一个 babel 插件。首先我们明确接下来要开发的插件的核心需求:")]),e._v(" "),t("ul",[t("li",[e._v("可自动插入某个函数并调用。")]),e._v(" "),t("li",[e._v("自动导入插入函数的相关依赖。")]),e._v(" "),t("li",[e._v("可以通过注释指定需要插入的函数和需要被插入的函数，若未用注释指定则默认插入位置在第一列。")])]),e._v(" "),t("p",[e._v("基本效果展示如下：")]),e._v(" "),t("p",[e._v("处理前")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("// log 声明需要被插入并被调用的方法\n// @inject:log\nfunction fn() {\n console.log(1)\n // 用 @inject:code指定插入行\n // @inject:code\n console.log(2)\n}\n复制代码\n")])])]),t("p",[e._v("处理后")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("// 导入包 xxx 之后要在插件参数内提供配置\nimport log from 'xxx'\nfunction fn() {\n console.log(1)\n log()\n console.log(2)\n}\n复制代码\n")])])]),t("h2",{attrs:{id:"思路整理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#思路整理"}},[e._v("#")]),e._v(" 思路整理")]),e._v(" "),t("p",[e._v("了解了大概的需求，先不着急动手，我们要先想想要怎么开始做，已经设想一下过程中需要处理的问题。")]),e._v(" "),t("ol",[t("li",[e._v("找到带有 @inject 标记的函数，再查看其内部是否有 @inject:code 的位置标记。")]),e._v(" "),t("li",[e._v("导入所有插入函数的相应包。")]),e._v(" "),t("li",[e._v("匹配到了标记，要做的就是插入函数，同时我们还要需要处理各种情况下的函数，如：对象方法、iife、箭头函数等等情况。")])]),e._v(" "),t("h2",{attrs:{id:"设计插件参数"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#设计插件参数"}},[e._v("#")]),e._v(" 设计插件参数")]),e._v(" "),t("p",[e._v("为了提升插件的灵活度，我们需要设计一个较为合适的参数规则。插件参数接受一个对象。")]),e._v(" "),t("ul",[t("li",[t("p",[e._v("key 作为插入函数的函数名。")])]),e._v(" "),t("li",[t("p",[e._v("kind 表示导入形式。有三种导入方式 named 、 default、 namespaced, 此设计参考 "),t("strong",[e._v("babel-helper-module-imports")]),e._v("[4]")])]),e._v(" "),t("li",[t("ul",[t("li",[e._v("named 对应 "),t("code",[e._v('import { a } from "b"')]),e._v(" 形式")]),e._v(" "),t("li",[e._v("default 对应 "),t("code",[e._v('import a from "b"')]),e._v(" 形式")]),e._v(" "),t("li",[e._v("namespaced 对应 "),t("code",[e._v('import * as a from "b"')]),e._v(" 形式")])])]),e._v(" "),t("li",[t("p",[e._v("require 为依赖的包名")])])]),e._v(" "),t("p",[e._v("比如，我需要插入 "),t("code",[e._v("log")]),e._v(" 方法，它需要从 "),t("code",[e._v("log4js")]),e._v(" 这个包里导入，并且是以 "),t("code",[e._v("named")]),e._v(" 形式， 参数便为如下形式。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("// babel.config.js\nmodule.exports = {\n  plugins: [\n // 填写我们的plugin的js 文件地址\n    ['./babel-plugin-myplugin.js', {\n      log: {\n        // 导入方式为 named\n        kind: 'named',\n        require: 'log4js'\n      }\n    }]\n  ]\n}\n复制代码\n")])])]),t("h2",{attrs:{id:"起步"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#起步"}},[e._v("#")]),e._v(" 起步")]),e._v(" "),t("p",[e._v("好，知道了具体要做什么事情并且设计好了参数的规则， 我们就可以开始动手了。")]),e._v(" "),t("p",[e._v("首先我们进入 "),t("strong",[e._v("astexplorer.net/")]),e._v("[5] 将待处理的 code 生成 AST 方便我们梳理结构， 然后我们在进行具体编码")]),e._v(" "),t("p",[e._v("首先是函数声明语句，我们分析一下其 AST 结构以及该如何处理， 来看一下demo")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("// @inject:log\nfunction fn() {\n console.log('fn')\n}\n复制代码\n")])])]),t("p",[e._v("其生成的 AST 结构如下，可以看到有比较关键的两个属性：")]),e._v(" "),t("ul",[t("li",[e._v("leadingComments 表示前方注释，可以看到内部有一个元素，就是我们demo里所写的 "),t("code",[e._v("@inject:log")])]),e._v(" "),t("li",[e._v("body 是函数体的具体内容， demo 所写的 "),t("code",[e._v("console.log('fn')")]),e._v(" 此时就在里面，我们等会代码的插入操作就是需要操作它")])]),e._v(" "),t("p",[t("img",{attrs:{src:"https://mmbiz.qpic.cn/mmbiz/pfCCZhlbMQRR1x1btjbliaibhknJlowibugia8icKDjev4gVmgT5cKo8zykP7erutLmJ5M41gVbDXqWTopl5vZSpqzg/640?wx_fmt=other&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1",alt:"图片"}}),e._v("file")]),e._v(" "),t("p",[e._v("好，知道了可以通过 "),t("code",[e._v("leadingComments")]),e._v(" 来获知函数是否需要被插入, 对 "),t("code",[e._v("body")]),e._v(" 操作可以实现我们的代码插入需求。。")]),e._v(" "),t("p",[e._v("首先我们得先找到 "),t("code",[e._v("FunctionDeclaration")]),e._v(" 这一层，因为只有这一层才有 "),t("code",[e._v("leadingComments")]),e._v("属性， 然后我们需要遍历它，匹配出需要插入的函数。再将匹配到的函数插入至 body 只中， 但我们这里需要注意可插入的body 所在层级， "),t("code",[e._v("FunctionDeclaration")]),e._v(" 内的body 他不是一个数组而是 "),t("code",[e._v("BlockStatement")]),e._v("，这表示函数的函数体，并且它也有body , 所以我们实际操作位置就在这个"),t("code",[e._v("BlockStatement")]),e._v(" 的 body 内")]),e._v(" "),t("p",[t("img",{attrs:{src:"https://mmbiz.qpic.cn/mmbiz/pfCCZhlbMQRR1x1btjbliaibhknJlowibugENtoRoQ5RYUiaBHqXjVUFickFRapjT74x9ma0BjWowjM7kgIqHaRu4yA/640?wx_fmt=other&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1",alt:"图片"}}),e._v("file")]),e._v(" "),t("p",[e._v("代码如下：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("module.exports = (api, options, dirname) => {\n\n  return {\n    visitor: {\n   // 匹配函数声明节点\n      FunctionDeclaration(path, state) {\n        // path.get('body') 相当于 path.node.body\n        const pathBody = path.get('body')\n        if(path.node.leadingComments) {\n          // 过滤出所有匹配 @inject:xxx 字符 的注释\n          const leadingComments = path.node.leadingComments.filter(comment => /\\@inject:(\\w+)/.test(comment.value) )\n          leadingComments.forEach(comment => {\n            const injectTypeMatchRes = comment.value.match(/\\@inject:(\\w+)/)\n            // 匹配成功\n            if( injectTypeMatchRes ) {\n              // 匹配结果的第一个为 @inject:xxx 中的 xxx ,  我们将它取出来\n              const injectType = injectTypeMatchRes[1]\n              // 获取插件参数的 key， 看xxx 是否在插件的参数中声明过\n              const sourceModuleList = Object.keys(options)\n              if( sourceModuleList.includes(injectType) ) {\n                // 搜索body 内部是否有 @code:xxx 注释\n                // 因为无法直接访问到 comment，所以需要访问 body内每个 AST 节点的 leadingComments 属性\n                const codeIndex = pathBody.node.body.findIndex(block => block.leadingComments && block.leadingComments.some(comment => new RegExp(`@code:\\s?${injectType}`).test(comment.value) ))\n                // 未声明则默认插入位置为第一行\n                if( codeIndex === -1 ) {\n                  // 操作`BlockStatement` 的 body\n         pathBody.node.body.unshift(api.template.statement(`${state.options[injectType].identifierName}()`)());\n                }else {\n                  pathBody.node.body.splice(codeIndex, 0, api.template.statement(`${state.options[injectType].identifierName}()`)());\n                }\n              }\n            }\n          })\n        }\n      }\n  }\n})\n\n复制代码\n")])])]),t("p",[e._v("编写完后我们看看结果， "),t("code",[e._v("log")]),e._v("成功被插入了， 因为我们没有使用 "),t("code",[e._v("@code:log")]),e._v("所以就默认插入在了第一行"),t("img",{attrs:{src:"https://mmbiz.qpic.cn/mmbiz/pfCCZhlbMQRR1x1btjbliaibhknJlowibug6SyBINw7c0t3x69IL7RiccX4lk9YlYbRAVM1iaL14eGhdnuF8HibtgOyg/640?wx_fmt=other&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1",alt:"图片"}})]),e._v(" "),t("p",[e._v("然后我们试试使用 "),t("code",[e._v("@code:log")]),e._v(" 标识符, 我们将 demo 的代码改为如下")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("// @inject:log\nfunction fn() {\n console.log('fn')\n // @code:log\n}\n复制代码\n")])])]),t("p",[e._v("再次运行代码查看结果， 确实是在 "),t("code",[e._v("@code:log")]),e._v(" 位置成功插入了"),t("img",{attrs:{src:"https://mmbiz.qpic.cn/mmbiz/pfCCZhlbMQRR1x1btjbliaibhknJlowibugPCH36g1xSXmnrBgz3X3Rez3sDicycwS7ZOVCmbeUic8iaqmiams0eFxX4w/640?wx_fmt=other&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1",alt:"图片"}})]),e._v(" "),t("p",[e._v("处理完了我们第一个案例函数声明，这时候可能有人会问了， 那箭头函数这种没有函数体的你怎么办, 比如：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("// @inject:log\n() => true\n复制代码\n")])])]),t("p",[e._v("这有问题吗？没有问题！")]),e._v(" "),t("p",[t("img",{attrs:{src:"https://mmbiz.qpic.cn/mmbiz/pfCCZhlbMQRR1x1btjbliaibhknJlowibugv1tLIyPc6939SDtPN0GPIrEtYAF8a4ibQrAbUuechtLxAq0FZVkTVcQ/640?wx_fmt=other&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1",alt:"图片"}}),e._v("file")]),e._v(" "),t("p",[e._v("没有函数体我们给它一个函数体就是了，怎么做呢？")]),e._v(" "),t("p",[e._v("首先我们还是先学会来分析一下 AST 结构， 首先看到最外层其实是一个"),t("code",[e._v("ExpressionStatement")]),e._v("表达式声明，然后其内部才是 "),t("code",[e._v("ArrowFunctionExpression")]),e._v("箭头函数表达式, 可见跟我们之前的函数声明生成的结构是大有不同， 其实我们不用被这么多层结构迷了眼睛，我们只需要找对我们有用的信息就可以了，一句话："),t("strong",[e._v("哪一层有 leadingComments 我们就找哪一层")]),e._v("。这里的 "),t("code",[e._v("leadingComments")]),e._v(" 在 "),t("code",[e._v("ExpressionStatement")]),e._v(" 上，所以我们找它就行")]),e._v(" "),t("p",[t("img",{attrs:{src:"https://mmbiz.qpic.cn/mmbiz/pfCCZhlbMQRR1x1btjbliaibhknJlowibugDWsMePjdTb4DQIt1M5MJ2A9V762ZLibrncTVjuu4O4Bt2TRELUkYSEw/640?wx_fmt=other&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1",alt:"图片"}}),e._v("file")]),e._v(" "),t("p",[e._v("分析完了结构，那怎么判断是否有函数体呢？还记得上面处理函数声明时，我们在 body 中看到的 "),t("code",[e._v("BlockStatement")]),e._v(" 吗，而你看到我们箭头函数的 body 却是 "),t("code",[e._v("BooleanLiteral")]),e._v("。所以，我们可以判断其 body 类型来得知是否有函数体 具体方法可以使用babel 提供的类型判断方法 "),t("code",[e._v("path.isBlockStatement()")]),e._v(" 来区分是否有函数体。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("module.exports = (api, options, dirname) => {\n\n  return {\n    visitor: {\n      ExpressionStatement(path, state) {\n        // 访问到 ArrowFunctionExpression\n        const expression = path.get('expression')\n        const pathBody = expression.get('body')\n        if(path.node.leadingComments) {\n          // 正则匹配 comment 是否有 @inject:xxx 字符\n          const leadingComments = path.node.leadingComments.filter(comment => /\\@inject:(\\w+)/.test(comment.value) )\n          \n          leadingComments.forEach(comment => {\n            const injectTypeMatchRes = comment.value.match(/\\@inject:(\\w+)/)\n            // 匹配成功\n            if( injectTypeMatchRes ) {\n              // 匹配结果的第一个为 @inject:xxx 中的 xxx ,  我们将它取出来\n              const injectType = injectTypeMatchRes[1]\n              // 获取插件参数的 key， 看xxx 是否在插件的参数中声明过\n\n              const sourceModuleList = Object.keys(options)\n              if( sourceModuleList.includes(injectType) ) {\n                // 判断是否有函数体\n                if (pathBody.isBlockStatement()) {\n                  // 搜索body 内部是否有 @code:xxx 注释\n                  // 因为无法直接访问到 comment，所以需要访问 body内每个 AST 节点的 leadingComments 属性\n                  const codeIndex = pathBody.node.body.findIndex(block => block.leadingComments && block.leadingComments.some(comment => new RegExp(`@code:\\s?${injectType}`).test(comment.value) ))\n                  // 未声明则默认插入位置为第一行\n                  if( codeIndex === -1 ) {\n                    pathBody.node.body.unshift(api.template.statement(`${injectType}()`)());\n                  }else {\n                    pathBody.node.body.splice(codeIndex, 0, api.template.statement(`${injectType}()`)());\n                  }\n                }else {\n                  // 无函数体情况\n                  // 使用 ast 提供的 `@babel/template`  api ， 用代码段生成 ast\n                  const ast = api.template.statement(`{${injectType}();return BODY;}`)({BODY: pathBody.node});\n     // 替换原本的body\n                  pathBody.replaceWith(ast);\n                }\n              }\n            }\n          })\n        }\n      }\n  }\n}\n}\n\n复制代码\n")])])]),t("p",[e._v("可以看到除了新增的函数体判断，生成函数体插入代码再用新的 AST 替换原本的节点，除掉这些之外，大体上的逻辑跟之前的函数声明的处理过程没有区别。")]),e._v(" "),t("blockquote",[t("p",[e._v("生成 AST 所使用的 "),t("code",[e._v("@babel/template")]),e._v(" 的 API 相关用法可以查看文档 "),t("strong",[e._v("@babel/template")]),e._v("[6]")])]),e._v(" "),t("p",[e._v("针对不同情况的下的函数大体上相同，总结就是：")]),e._v(" "),t("p",[t("em",[e._v("分析 AST 找到 "),t("code",[e._v("leadingComments")]),e._v(" 所在节点 -> 找到可插入的 body 所在节点 -> 编写插入逻辑")])]),e._v(" "),t("p",[e._v("实际处理的情况还有很多，如：对象属性、iife、函数表达式等很多， 处理思路都是一样的，这里就不过重复阐述。我会将插件完整代码发在文章底部。")]),e._v(" "),t("h2",{attrs:{id:"自动引入"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#自动引入"}},[e._v("#")]),e._v(" 自动引入")]),e._v(" "),t("p",[e._v("第一条完成了，那需求的第二条，我们使用的包如何自动引入呢， 如上面案例使用的 "),t("code",[e._v("log4js")]),e._v("， 那么我们处理后的代码就应该自动加上：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("import { log } from 'log4js'\n复制代码\n")])])]),t("p",[e._v("此时，我们可以思考一下，我们需要处理以下两种情况")]),e._v(" "),t("ol",[t("li",[e._v("log 已经被导入过了")]),e._v(" "),t("li",[e._v("log 变量名已经被占用")])]),e._v(" "),t("p",[e._v("针对 问题1 我们需要先检索一下是否有导入过 "),t("code",[e._v("log4js")]),e._v(" ，并且以 "),t("code",[e._v("named")]),e._v(" 的形式导入了 "),t("code",[e._v("log")]),e._v(" 针对 问题2 我们需要给 "),t("code",[e._v("log")]),e._v(" 一个唯一的别名， 并且要保证在后续的代码插入中也使用这个别名。所以这就要求了我们要在文件的一开始就处理完成自动引入的逻辑。")]),e._v(" "),t("p",[e._v("有了大概的思路，但是我们如何提前完成自动引入逻辑呢。抱着疑问，我们再来看看 AST 的结构。可以看到 AST 最外层是 "),t("code",[e._v("File")]),e._v(" 节点, 他有一个 "),t("code",[e._v("comments")]),e._v(" 属性，它包含了当前文件里所有的注释，有了这个我们就可以解析出文件里需要插入的函数，并提前进行引入。我们再往下看， 内部是一个 "),t("code",[e._v("Program")]),e._v(", 我们将首先访问它， 因为它会在其他类型的节点之前被调用，所以我们要在此阶段实现自动引入逻辑。")]),e._v(" "),t("blockquote",[t("p",[e._v("小知识：babel 提供了 path.traverse 方法，可以用来同步访问处理当前节点下的子节点。")])]),e._v(" "),t("p",[e._v("如图："),t("img",{attrs:{src:"https://mmbiz.qpic.cn/mmbiz/pfCCZhlbMQRR1x1btjbliaibhknJlowibugiax1iamhAXc81ia3icqsegrCwBWNDibAk9q9WJv6UWvXB3jU4m7wGfaxUoA/640?wx_fmt=other&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1",alt:"图片"}})]),e._v(" "),t("p",[e._v("代码如下:")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("const importModule = require('@babel/helper-module-imports');\n\n// ......\n{\n    visitor: {\n      Program(path, state) {\n        // 拷贝一份options 挂在 state 上,  原本的 options 不能操作\n        state.options = JSON.parse(JSON.stringify(options))\n\n        path.traverse({\n          // 首先访问原有的 import 节点， 检测 log 是否已经被导入过\n          ImportDeclaration (curPath) {\n            const requirePath = curPath.get('source').node.value;\n            // 遍历options\n            Object.keys(state.options).forEach(key => {\n              const option = state.options[key]\n              // 判断包相同\n              if( option.require === requirePath ) {\n                const specifiers = curPath.get('specifiers')\n                specifiers.forEach(specifier => {\n\n                  // 如果是默认type导入\n                  if( option.kind === 'default' ) {\n                    // 判断导入类型\n                    if( specifier.isImportDefaultSpecifier() ) {\n                      // 找到已有 default 类型的引入\n                      if( specifier.node.imported.name === key ) {\n                        // 挂到 identifierName 以供后续调用获取\n                        option.identifierName = specifier.get('local').toString()\n                      }\n                    }\n                  }\n\n                    // 如果是 named 形式的导入\n                  if( option.kind === 'named' ) {\n                    // \n                    if( specifier.isImportSpecifier() ) {\n                      // 找到已有 default 类型的引入\n                      if( specifier.node.imported.name === key ) {\n                        option.identifierName = specifier.get('local').toString()\n                      }\n                    }\n                  }\n                })\n              }\n            })\n          }\n        });\n\n\n        // 处理未被引入的包\n        Object.keys(state.options).forEach(key => {\n          const option = state.options[key]\n          // 需要require 并且未找到 identifierName 字段\n          if( option.require && !option.identifierName )  {\n            \n            // default形式\n            if( option.kind === 'default' ) {\n              // 增加 default 导入\n              // 生成一个随机变量名, 大致上是这样 _log2\n              option.identifierName = importModule.addDefault(path, option.require, {\n                nameHint: path.scope.generateUid(key)\n              }).name;\n            }\n\n            // named形式\n            if( option.kind === 'named' ) {\n              option.identifierName = importModule.addNamed(path, key, option.require, {\n                nameHint: path.scope.generateUid(key)\n              }).name\n            }\n          }\n\n          // 如果没有传递 require 会认为是全局方法，不做导入处理\n          if( !option.require ) {\n            option.identifierName = key\n          }\n        })\n    }\n  }\n}\n复制代码\n")])])]),t("p",[t("code",[e._v("Program")]),e._v(" 节点内我们先将接收到的插件配置 "),t("code",[e._v("options")]),e._v(" 拷贝了一份，挂到了 "),t("code",[e._v("state")]),e._v(" 上， 之前有说过 "),t("code",[e._v("state")]),e._v(" 可以用作 AST 节点之间的数据传递，然后我们首先访问 "),t("code",[e._v("Program")]),e._v(" 下的 "),t("code",[e._v("ImportDeclaration")]),e._v(" 也就是 "),t("code",[e._v("import")]),e._v(" 语句, 看看 "),t("code",[e._v("log4js")]),e._v(" 是否有被导入过， 若引入过便会记录到 "),t("code",[e._v("identifierName")]),e._v(" 字段上，完成对 "),t("code",[e._v("import")]),e._v(" 语句的访问后，我们就可根据 "),t("code",[e._v("identifierName")]),e._v(" 字段判断是否已被引入，若未引入则使用 "),t("strong",[e._v("@babel/helper-module-imports")]),e._v("[7] 创建 "),t("code",[e._v("import")]),e._v(" ，并用 babel 提供的 "),t("code",[e._v("generateUid")]),e._v(" 方法创建唯一的变量名。")]),e._v(" "),t("p",[e._v("这样在之前的代码我们也需要略微调整， 不能直接使用从注释 "),t("code",[e._v("@inject:xxx")]),e._v(" 提取出的方法名， 而是应该使用 "),t("code",[e._v("identifierName")]),e._v("， 关键部分代码修改如下：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("if( sourceModuleList.includes(injectType) ) {\n  // 判断是否有函数体\n  if (pathBody.isBlockStatement()) {\n    // 搜索body 内部是否有 @code:xxx 注释\n    // 因为无法直接访问到 comment，所以需要访问 body内每个 AST 节点的 leadingComments 属性\n    const codeIndex = pathBody.node.body.findIndex(block => block.leadingComments && block.leadingComments.some(comment => new RegExp(`@code:\\s?${injectType}`).test(comment.value) ))\n    // 未声明则默认插入位置为第一行\n    if( codeIndex === -1 ) {\n      // 使用 identifierName \n      pathBody.node.body.unshift(api.template.statement(`${state.options[injectType].identifierName}()`)());\n    }else {\n      // 使用 identifierName \n      pathBody.node.body.splice(codeIndex, 0, api.template.statement(`${state.options[injectType].identifierName}()`)());\n    }\n  }else {\n    // 无函数体情况\n    // 使用 ast 提供的 `@babel/template`  api ， 用代码段生成 ast\n\n    // 使用 identifierName \n    const ast = api.template.statement(`{${state.options[injectType].identifierName}();return BODY;}`)({BODY: pathBody.node});\n    // 替换原本的body\n    pathBody.replaceWith(ast);\n  }\n}\n复制代码\n")])])]),t("p",[e._v("最终效果如下：")]),e._v(" "),t("p",[t("img",{attrs:{src:"https://mmbiz.qpic.cn/mmbiz/pfCCZhlbMQRR1x1btjbliaibhknJlowibug2gmj9Z2O0eq92Oiaz4Hmp5xT915UGAL63824veia6GmoEUP4AKSrCGng/640?wx_fmt=other&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1",alt:"图片"}}),e._v("file")]),e._v(" "),t("p",[e._v("我们实现了函数自动插入并自动引入依赖包。")]),e._v(" "),t("h2",{attrs:{id:"结尾"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#结尾"}},[e._v("#")]),e._v(" 结尾")]),e._v(" "),t("p",[e._v("本篇文章是对自己学习 “Babel 插件通关秘籍” 小册子后的一个记录总结，我开始和大部分想写babel插件却无从下手的同学一样，所以这篇文章主要也是按自己写插件时摸索的思路去写。希望也是能给大家提供一个思路。")]),e._v(" "),t("p",[e._v("完整版已支持 "),t("code",[e._v("自定义代码片段")]),e._v(" 的插入，完整代码已上传至 "),t("strong",[e._v("github")]),e._v("**：https://github.com/nxl3477/babel-plugin-code-inject**，同时也发布至了 "),t("strong",[e._v("npm")]),e._v("**：https://www.npmjs.com/package/babel-plugin-code-inject**。 欢迎大家 star 和 issue。")])])}),[],!1,null,null,null);t.default=o.exports}}]);
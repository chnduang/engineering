<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>大型复杂前端工程的优化方法 | duangdong的engineering</title>
    <meta name="generator" content="VuePress 1.9.10">
    <link rel="icon" href="/logo.png">
    <link rel="manifest" href="/manifest.json">
    <script>
  var _hmt = _hmt || [];
  (function() {
    var hm = document.createElement("script");
    hm.src = "https://hm.baidu.com/hm.js?0088ce24040b03f2947322ab31d23414";
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(hm, s);
  })();
  </script>
    <script>
  var _hmt = _hmt || [];
  _hmt.push(['_requirePlugin', 'UrlChangeTracker', {
    shouldTrackUrlChange: function (newPath, oldPath) {
      newPath = newPath.split('#')[0];
      oldPath = oldPath.split('#')[0];
      return newPath != oldPath;
    }}
  ]);
  </script>
    <meta name="description" content="前端相关知识归纳总结">
    <meta name="keywords" content="qd-blog,node,vuepress,leetcode,algorithm">
    
    <link rel="preload" href="/assets/css/0.styles.b4a844ec.css" as="style"><link rel="preload" href="/assets/js/app.04fd048c.js" as="script"><link rel="preload" href="/assets/js/2.57da4f88.js" as="script"><link rel="preload" href="/assets/js/1.a76cc220.js" as="script"><link rel="preload" href="/assets/js/35.4656aa60.js" as="script"><link rel="prefetch" href="/assets/js/10.50f73657.js"><link rel="prefetch" href="/assets/js/11.0390ceee.js"><link rel="prefetch" href="/assets/js/12.f88bec36.js"><link rel="prefetch" href="/assets/js/13.963ad03b.js"><link rel="prefetch" href="/assets/js/14.512f15b9.js"><link rel="prefetch" href="/assets/js/15.a674496c.js"><link rel="prefetch" href="/assets/js/16.ed7e507f.js"><link rel="prefetch" href="/assets/js/17.de667ca5.js"><link rel="prefetch" href="/assets/js/18.b44e84af.js"><link rel="prefetch" href="/assets/js/19.5b5ad6a1.js"><link rel="prefetch" href="/assets/js/20.6800493a.js"><link rel="prefetch" href="/assets/js/21.6589052c.js"><link rel="prefetch" href="/assets/js/22.f648d829.js"><link rel="prefetch" href="/assets/js/23.d80486b4.js"><link rel="prefetch" href="/assets/js/24.d1ded971.js"><link rel="prefetch" href="/assets/js/25.2b5651f2.js"><link rel="prefetch" href="/assets/js/26.be0532f1.js"><link rel="prefetch" href="/assets/js/27.601e9758.js"><link rel="prefetch" href="/assets/js/28.5f3c5013.js"><link rel="prefetch" href="/assets/js/29.b11be3d0.js"><link rel="prefetch" href="/assets/js/3.13e892f5.js"><link rel="prefetch" href="/assets/js/30.b5a85a3d.js"><link rel="prefetch" href="/assets/js/31.656e3cca.js"><link rel="prefetch" href="/assets/js/32.df47284c.js"><link rel="prefetch" href="/assets/js/33.cf2bef7f.js"><link rel="prefetch" href="/assets/js/34.b76a28cc.js"><link rel="prefetch" href="/assets/js/36.bc0d7be9.js"><link rel="prefetch" href="/assets/js/37.41e22cc1.js"><link rel="prefetch" href="/assets/js/38.9a20d42b.js"><link rel="prefetch" href="/assets/js/39.5d96398a.js"><link rel="prefetch" href="/assets/js/4.5bdb9365.js"><link rel="prefetch" href="/assets/js/40.fb9028aa.js"><link rel="prefetch" href="/assets/js/41.96d148c1.js"><link rel="prefetch" href="/assets/js/42.26c75454.js"><link rel="prefetch" href="/assets/js/43.59ed847d.js"><link rel="prefetch" href="/assets/js/44.4c9bed25.js"><link rel="prefetch" href="/assets/js/45.547c992f.js"><link rel="prefetch" href="/assets/js/46.d63785ae.js"><link rel="prefetch" href="/assets/js/47.34a532a7.js"><link rel="prefetch" href="/assets/js/48.81fda019.js"><link rel="prefetch" href="/assets/js/49.3039c755.js"><link rel="prefetch" href="/assets/js/5.7c68fdb5.js"><link rel="prefetch" href="/assets/js/50.bd461786.js"><link rel="prefetch" href="/assets/js/51.b83fa154.js"><link rel="prefetch" href="/assets/js/52.6880a119.js"><link rel="prefetch" href="/assets/js/53.f60e17c7.js"><link rel="prefetch" href="/assets/js/54.833a4f5c.js"><link rel="prefetch" href="/assets/js/55.ed6a7c66.js"><link rel="prefetch" href="/assets/js/56.c9eef7e1.js"><link rel="prefetch" href="/assets/js/57.abbfb924.js"><link rel="prefetch" href="/assets/js/58.c1df5fda.js"><link rel="prefetch" href="/assets/js/59.1615eb2d.js"><link rel="prefetch" href="/assets/js/6.c8da7ca7.js"><link rel="prefetch" href="/assets/js/60.a1480688.js"><link rel="prefetch" href="/assets/js/61.901ae4d3.js"><link rel="prefetch" href="/assets/js/62.dc705c01.js"><link rel="prefetch" href="/assets/js/63.a3367f7e.js"><link rel="prefetch" href="/assets/js/64.44397e2a.js"><link rel="prefetch" href="/assets/js/65.b6f8a966.js"><link rel="prefetch" href="/assets/js/66.305bd539.js"><link rel="prefetch" href="/assets/js/67.b47bf615.js"><link rel="prefetch" href="/assets/js/68.63565465.js"><link rel="prefetch" href="/assets/js/69.141e956c.js"><link rel="prefetch" href="/assets/js/7.e4c88d0e.js"><link rel="prefetch" href="/assets/js/vendors~docsearch.5143d2e0.js">
    <link rel="stylesheet" href="/assets/css/0.styles.b4a844ec.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">duangdong的engineering</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/engineering/" class="nav-link router-link-active">
  工程化
</a></div><div class="nav-item"><a href="/webpack/" class="nav-link">
  Webpack
</a></div><div class="nav-item"><a href="/webpack-explain/" class="nav-link">
  深入浅出Webpack
</a></div><div class="nav-item"><a href="/babel/" class="nav-link">
  Babel
</a></div><div class="nav-item"><a href="/micro-front/" class="nav-link">
  微前端
</a></div><div class="nav-item"><a href="https://link.aduang.cn" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Home
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/engineering/" class="nav-link router-link-active">
  工程化
</a></div><div class="nav-item"><a href="/webpack/" class="nav-link">
  Webpack
</a></div><div class="nav-item"><a href="/webpack-explain/" class="nav-link">
  深入浅出Webpack
</a></div><div class="nav-item"><a href="/babel/" class="nav-link">
  Babel
</a></div><div class="nav-item"><a href="/micro-front/" class="nav-link">
  微前端
</a></div><div class="nav-item"><a href="https://link.aduang.cn" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Home
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/engineering/" aria-current="page" class="sidebar-link">前端工程化</a></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>3-npm</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>4-vite</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>6-gulp</span> <span class="arrow right"></span></p> <!----></section></li><li><a href="/engineering/大型复杂前端工程的优化方法.html" class="active sidebar-link">大型复杂前端工程的优化方法</a></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>罗列</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="大型复杂前端工程的优化方法"><a href="#大型复杂前端工程的优化方法" class="header-anchor">#</a> 大型复杂前端工程的优化方法</h1> <blockquote><p><a href="https://mp.weixin.qq.com/s/0m_Sz1DXrd9JKrA-6SUg2w" target="_blank" rel="noopener noreferrer">https://mp.weixin.qq.com/s/0m_Sz1DXrd9JKrA-6SUg2w<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></blockquote> <h2 id="前言"><a href="#前言" class="header-anchor">#</a> 前言</h2> <p>对于前端来讲，如果是去写一个简单页面，其实在写的过程中，很少会考虑到性能优化、错误监控这些。因为就一个页面而言，并不会对整个项目造成影响。但是就一个大型合作的前端项目而言，如果每个人不考虑性能优化的话，轻一点的问题就是：页面卡顿，操作不流畅。重一点的问题就是：页面卡死，内存崩溃，各种告警。所以基于了解,实践与收集，本人在此收集了大型前端项目中的一些性能优化方法，用以分享。不对地方还请斧正～</p> <h2 id="_1-实现优化"><a href="#_1-实现优化" class="header-anchor">#</a> 1.实现优化</h2> <h3 id="_1-1-容器化"><a href="#_1-1-容器化" class="header-anchor">#</a> 1.1 容器化</h3> <p>所谓的容器，即对于不同的文档，打开时，不再加载重复的代码，只需加载不同的文档数据即可。容器化有两种实现思路：</p> <h4 id="_1-借助于客户端"><a href="#_1-借助于客户端" class="header-anchor">#</a> 1. 借助于客户端</h4> <p>典型场景：列表页--&gt;选定文档--&gt;打开文档</p> <p>用户选定文档后，点击链接进行打开的时候，并不会真的去打开一个新的 webview，而是进行 webview 的切换，APP 会一直保留一个 webview（代码已经加载好，是文档容器），此时将文档链接赋予容器，容器只需要拉取对应数据，不再重新加载新代码。</p> <h4 id="_2-将代码集合到一个页面中-spa-方案"><a href="#_2-将代码集合到一个页面中-spa-方案" class="header-anchor">#</a> 2. 将代码集合到一个页面中（SPA 方案）</h4> <p>典型场景：列表页--&gt;选定文档--&gt;打开文档</p> <p>当打开列表页后，然后迅速懒加载对应的文档容器代码。用户点击指定文档时，不再打开新的 webview 页面，而只是当前页面进行容器切换。用户退回列表页，仍然是在当前页面。</p> <h3 id="_1-2-离线缓存"><a href="#_1-2-离线缓存" class="header-anchor">#</a> 1.2 离线缓存</h3> <p>离线缓存处理的核心难点在于：离线数据的处理。离线资源处理现在一般有两种方案：</p> <h4 id="_1-借助于客户端-2"><a href="#_1-借助于客户端-2" class="header-anchor">#</a> 1. 借助于客户端</h4> <p>典型场景：打开列表页。</p> <p>当网页打开请求 html/js/css/图片的时候，APP 拦截网络请求，查找是否命中本地的资源，命中即直接返回。此场景需要注意客户端要建立代码更新机制，更新离线代码包。</p> <h4 id="_2-service-workers"><a href="#_2-service-workers" class="header-anchor">#</a> 2. service workers</h4> <p>典型场景：打开列表页。</p> <p>将资源注册后便能使用。但是必须使用 https 协议，同时还有 ios webview 兼容性问题。</p> <blockquote><p>可以参考这篇文章：前端离线化探索（http://www.alloyteam.com/2019/07/web-applications-offline/）</p></blockquote> <h3 id="_1-3-数据序列化"><a href="#_1-3-数据序列化" class="header-anchor">#</a> 1.3 数据序列化</h3> <p>典型场景：打开文档拉取后台数据的时候。</p> <p>数据序列化即：将数据结构或对象编码，然后在网络间传输。</p> <p>常见的协议有 XML/JSON/PB 等。对于一个很大的文档来言，xml 或者 json 用来传输数据，太过于冗余。但是如果采用复杂度太高的压缩算法如：Pako.js， 那这样反而提高了解压缩时间，得不偿失，所以找到一个适合的数据序列化方法至关重要。</p> <h3 id="_1-4-按需加载"><a href="#_1-4-按需加载" class="header-anchor">#</a> 1.4 按需加载</h3> <h4 id="_1-4-1-读写分离"><a href="#_1-4-1-读写分离" class="header-anchor">#</a> 1.4.1 读写分离</h4> <p>典型场景：打开文档拉取文档代码的时候。</p> <p>读写分离也是按需加载的一种形式。</p> <p>读写分离即：将用户区分开来，并不是所有的用户都要加载所有的代码，读的用户只需要加载读的代码，写的用户才需要读写的代码，这样对于读的用户较为友好。</p> <h4 id="_1-4-2-按需引入"><a href="#_1-4-2-按需引入" class="header-anchor">#</a> 1.4.2 按需引入</h4> <p>典型场景：开发中进行第三方库引入。</p> <p>按需引入即只引用需要的代码。</p> <p>按需引入常常会在开发中被忽略。如 只需要 lodash 中一个函数 <code>isEqual</code>，却将整个工具库进行了引入。 <code>import_from'lodash'</code>，无形增加更多冗余代码。通过引入单个函数即可改正： <code>importisEqualfrom'lodash.isEqual'</code>。</p> <h3 id="_1-5-懒加载"><a href="#_1-5-懒加载" class="header-anchor">#</a> 1.5 懒加载</h3> <p>典型场景：文档中一些比较不常用的功能。</p> <p>懒加载即：对于部分功能代码等到需要的时候再进行加载。</p> <p>懒加载有利于首屏打开时间。文档中一些不常用的功能，对于用户来讲，如果每次打开都去加载对应的代码，无疑是冗余的。通过拆分代码，等到用户需要时或者点击时，再去加载对应的代码。</p> <h3 id="_1-6-使用-web-worker"><a href="#_1-6-使用-web-worker" class="header-anchor">#</a> 1.6 使用 web worker</h3> <p>典型场景：文档中打开时有大量复杂计算时。</p> <p>web worker 是运行在后台的 JavaScript，不会影响页面的性能。</p> <p>web worker 无疑是解决 js 计算能力弱的一大利器。如果将文档中复杂计算放到主线程中，页面卡顿不说，打开复杂文档的时候还很有可能崩溃掉。将计算挪入 web worker 中，将计算结果事件回调的方式返回，可以让用户使用更加流畅。</p> <h3 id="_1-7-正则表达式"><a href="#_1-7-正则表达式" class="header-anchor">#</a> 1.7 正则表达式</h3> <p>典型场景： 文档中的函数或者文本进行匹配的时候。</p> <p>不好的正则表达式极易引起性能问题。其核心问题在于：js 的正则匹配是基于 NFA 的，易引起回溯问题。</p> <p>正则引擎分为 NFA（非确定性有限状态自动机），和 DFA（确定性有限状态自动机）。</p> <p>DFA 对于给定的任意一个状态和输入字符，DFA 只会转移到一个确定的状态。并且 DFA 不允许出现没有输入字符的状态转移。而 NFA 对于任意一个状态和输入字符，NFA 所能转移的状态是一个非空集合。模糊匹配、贪婪匹配、惰性匹配都会带来回溯问题。典型的正则匹配如 <code>(.\*)+\d</code> ，便会进行回溯。那么平时开发的时候，</p> <ol><li>正则要越精确越好</li> <li>改用 DFA 的正则引擎</li></ol> <p>具体可以参考：浅谈正则表达式原理</p> <h3 id="_1-8-使用缓存"><a href="#_1-8-使用缓存" class="header-anchor">#</a> 1.8 使用缓存</h3> <p>典型场景：一堆非常需要耗时的数据，每次更新都需要重新计算，但是更新的频率并不高。</p> <p>使用缓存可以有效的减少查找时间。</p> <p>js 引擎是单线程的，对于大量复杂耗时的计算，会导致页面卡顿。可以通过将计算挪入 worker 中计算，也可以对于更新不频繁的计算进行缓存。</p> <ul><li></li> <li></li> <li></li> <li></li> <li></li></ul> <div class="language- extra-class"><pre class="language-text"><code>function complexCompute(){  let result;  ...  return result;}
</code></pre></div><p>对于这种复杂计算，如果每次需要用到数据的时候都要去进行计算，那就得不偿失了，通过缓存，便能有效减少计算次数。</p> <ul><li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li></ul> <div class="language- extra-class"><pre class="language-text"><code>// 加入缓存let cache;function complexCompute(){  let result;  ...  cache = result;  return result;}
function getResult (){  // 有更新的时候再进行计算  if(update){    complexCompute();  }  return cache;}
</code></pre></div><p>这样便只会在更新的时候才会进行计算。</p> <h3 id="_1-9-建立索引"><a href="#_1-9-建立索引" class="header-anchor">#</a> 1.9 建立索引</h3> <p>典型场景：查找一堆复杂数据，并且每个数据都有唯一 key。</p> <p>建立索引的方式可以快速的提高查找速度。如一堆数据用数组进行存储。</p> <ul><li></li> <li></li> <li></li> <li></li></ul> <div class="language- extra-class"><pre class="language-text"><code>const persons = [  { name: &quot;zhangsan&quot;, age: 12 },  { name: &quot;lisi&quot;, age: 11 },];
</code></pre></div><p>和用对象的方式进行存储。</p> <ul><li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li></ul> <div class="language- extra-class"><pre class="language-text"><code>const persons = {  zhangsan: {    age: 12,  },  lisi: {    age: 11,  },};
</code></pre></div><p>进行查找 zhangsan 的 age，那么用数组的方式进行查找的时间复杂度是o(N)，用对象的时间复杂度是o(1)。</p> <h1 id="_2-架构优化"><a href="#_2-架构优化" class="header-anchor">#</a> 2.架构优化</h1> <h2 id="_2-1-设计模式六大基本原则"><a href="#_2-1-设计模式六大基本原则" class="header-anchor">#</a> 2.1 设计模式六大基本原则</h2> <p>五大原则和一个法则：</p> <ul><li><strong>单一职责原则(Single Responsibility Principle, SRP)</strong>: 一个类只负责一个功能领域中的相应职责，或者可以定义为：就一个类而言，应该只有一个引起它变化的原因</li> <li><strong>开闭原则(Open-Closed Principle, OCP)</strong>: 一个软件实体应当对扩展开放，对修改关闭</li> <li><strong>里氏代换原则(Liskov Substitution Principle, LSP)</strong>: 所有引用基类（父类）的地方必须能透明地使用其子类的对象</li> <li><strong>依赖倒转原则(Dependency Inversion Principle, DIP)</strong>: 抽象不应该依赖于细节，细节应当依赖于抽象。换言之，要针对接口编程，而不是针对实现编程</li> <li><strong>接口隔离原则(Interface Segregation Principle, ISP)</strong>: 使用多个专门的接口，而不使用单一的总接口，即客户端不应该依赖那些它不需要的接口。</li> <li><strong>迪米特法则(Law of Demeter, LoD)（最少知识法则）</strong>: 一个软件实体应当尽可能少地与其他实体发生相互作用。</li></ul> <h2 id="_2-2-组件库"><a href="#_2-2-组件库" class="header-anchor">#</a> 2.2 组件库</h2> <p>它的核心意义在于代码复用。功能相对单一或者独立，在整个系统的代码层次上位于最底层，被其他代码所依赖。比如说我们常用的一些 UI 组件，逻辑组件等。</p> <p>组件的核心在于：</p> <ol><li>通用性</li> <li>与业务无关</li> <li>兼容性</li></ol> <p>通过将一些通用的 UI 和逻辑拆分成组件，不仅可以让代码更简洁，更容易维护，而且高内聚，低耦合。</p> <h2 id="_2-3-lerna-管理"><a href="#_2-3-lerna-管理" class="header-anchor">#</a> 2.3 lerna 管理</h2> <p>当一个大的项目库代码量剧增之后，管理起来就是一件比较麻烦的事情，为了方便代码的共享，就需要将代码库拆分成独立的包。Lerna 便是优化和管理 JS 多包项目的利器。</p> <p>典型目录如下所示：</p> <ul><li></li> <li></li> <li></li></ul> <div class="language- extra-class"><pre class="language-text"><code>base/package.json;packages/package-1/ package.json;package-2/package.json;
</code></pre></div><h2 id="_2-4-享元模式"><a href="#_2-4-享元模式" class="header-anchor">#</a> 2.4 享元模式</h2> <p>典型场景：excel 的 openxml 规范。</p> <p>享元模式（Flyweight Pattern）主要用于减少创建对象的数量，以减少内存占用和提高性能。这种类型的设计模式属于结构型模式，它提供了减少对象数量从而改善应用所需的对象结构的方式。</p> <p>openxml 中对于数据的管理，基本上都是用享元模式实现的。</p> <p>如 1 个文档中有 1000 个相同的字符串。 <img src="https://mmbiz.qpic.cn/mmbiz_png/q2ntl21QGgVlrvQzIDBx5icyZqRMFdiaR1Mxbe7ksc4Hu4hlMIwZGw4KlkogtwuxxAVH0WoqqUgkaQqpj6SicBIfA/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p> <p>excel 并不会真的就存储 1000 个字符串。他只会存储一个字符串。</p> <p><img src="https://mmbiz.qpic.cn/mmbiz_png/q2ntl21QGgVlrvQzIDBx5icyZqRMFdiaR18lnbC7VQLeOuhoYS0saicyZLO8o5VxrRx1OOhARrzBib6yMR6bqqTt0w/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p> <p>而具体每个格子存储的是这个字符的下标索引。</p> <p><img src="https://mmbiz.qpic.cn/mmbiz_png/q2ntl21QGgVlrvQzIDBx5icyZqRMFdiaR1QA7bXQHWZYlYJ3Ac0uW6GSJ6VyfaWDk8kPpkzlCIRMIv3RXtumcY9w/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p> <p>这样无疑大大节省了存储空间。</p> <h1 id="_3-构建优化"><a href="#_3-构建优化" class="header-anchor">#</a> 3. 构建优化</h1> <h2 id="_3-1-webpack-打包优化"><a href="#_3-1-webpack-打包优化" class="header-anchor">#</a> 3.1 webpack 打包优化</h2> <h3 id="_3-1-1-公共包"><a href="#_3-1-1-公共包" class="header-anchor">#</a> 3.1.1 公共包</h3> <p>webpack3 是用的CommonsChunkPlugin用以实现提取第三方库和公共模块如 node_modules 下面的文件。</p> <p><img src="https://mmbiz.qpic.cn/mmbiz_png/q2ntl21QGgVlrvQzIDBx5icyZqRMFdiaR15jyGAd97MFXbaaQh1ljXkwn8K7D6ssdQLrUeEQ58wLZBtVibx5RGonA/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p> <p>webpack4 进行了改进，用optimization.splitChunks代替了 CommonsChunkPlugin。 commonschunkPlugin 的问题在于：它将所有的公共包合成了一个 commonChunk，但是并不是所有的子模块需要这个 commonChunk 的所有内容。</p> <p><img src="https://mmbiz.qpic.cn/mmbiz_png/q2ntl21QGgVlrvQzIDBx5icyZqRMFdiaR1XlT9CESosgiavKd9DnmbOT5hxhYqtuObnqWrJAxxbibFU2HKotbsGHWw/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p> <p>与 CommonsChunkPlugin 的父子关系思路不同的是，SplitChunksPlugin 引入了 chunkGroup 的概念，在入口 chunk 和异步 chunk 中发现被重复使用的模块，将重叠的模块以 vendor-chunk 的形式分离出来，也就是 vendor-chunk 可能有多个，不再受限于是所有 chunk 中都共同存在的模块。</p> <p>splitChunks 是开箱即用的，常见配置如下：</p> <ul><li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li></ul> <div class="language- extra-class"><pre class="language-text"><code>optimization: {  splitChunks: {    chunks: 'all',    minSize: 20000,    maxSize: 0,    minChunks: 1,    maxAsyncRequests: 6,    maxInitialRequests: 4,    automaticNameDelimiter: '~',    enforceSizeThreshold: 50000,    cacheGroups: {      defaultVendors: {        test: /[\\/]node_modules[\\/]/,        priority: -10      }    }  }}
</code></pre></div><p>可以通过 cacheGroup 制定更细的规则。</p> <h3 id="_3-1-2-动态导入-dynamic-imports"><a href="#_3-1-2-动态导入-dynamic-imports" class="header-anchor">#</a> 3.1.2 动态导入(dynamic imports)</h3> <p>通过动态导入进而实现懒加载和代码分离，进而可以用于获取更小的 bundle，以及控制资源加载优先级，如果使用合理，会极大影响加载时间。</p> <p>当涉及到动态代码拆分时，webpack 提供了两个类似的技术。对于动态导入，第一种，也是优先选择的方式是，使用符合 ECMAScript 提案 的 <code>import()</code>语法。如下所示：</p> <ul><li></li> <li></li> <li></li></ul> <div class="language- extra-class"><pre class="language-text"><code>return import(/* webpackChunkName: &quot;lodash&quot; */ &quot;lodash&quot;).then((_) =&gt; {  _.join([&quot;Hello&quot;, &quot;webpack&quot;]);});
</code></pre></div><h3 id="_3-1-3-tree-shaking"><a href="#_3-1-3-tree-shaking" class="header-anchor">#</a> 3.1.3 tree-shaking</h3> <p>tree-shaking 通常用于描述移除 JavaScript 上下文中的未引用代码(dead-code)。比如：</p> <p>index.js</p> <ul><li></li> <li></li></ul> <div class="language- extra-class"><pre class="language-text"><code>import { cube } from &quot;./math.js&quot;;console.log(cube(5));
</code></pre></div><p>cube.js</p> <ul><li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li></ul> <div class="language- extra-class"><pre class="language-text"><code>export function square(x) {  return x * x;}
export function cube(x) {  return x * x * x;}
</code></pre></div><p>其中 cube.js 中的square就属于未引用代码，打包时不需要。 通过在依赖包中的 package.json 里面写入：</p> <ul><li></li></ul> <div class="language- extra-class"><pre class="language-text"><code>&quot;sideEffects&quot;: false,
</code></pre></div><p>即可开启依赖包的 tree-shaking。</p> <p>但是使用 tree-shaking 要有三条规则。</p> <ol><li>使用 ES2015 模块语法（即 import 和 export）。</li> <li>在项目 package.json 文件中，添加一个 &quot;sideEffects&quot; 入口。</li> <li>引入一个能够删除未引用代码(dead code)的压缩工具(minifier)（例如 UglifyJSPlugin）。</li></ol> <p>具体的例子可以看 https://github.com/webpack/webpack/tree/master/examples/side-effects 这个。</p></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">上次更新:</span> <span class="time">5/8/2024, 3:01:19 PM</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/engineering/6-gulp/gulpfile-js.html" class="prev">
        gulp-示例
      </a></span> <span class="next"><a href="/engineering/罗列/ESlint语法检查简单配置.html">
        ESlint语法检查简单配置
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"><!----><!----></div></div>
    <script src="/assets/js/app.04fd048c.js" defer></script><script src="/assets/js/2.57da4f88.js" defer></script><script src="/assets/js/1.a76cc220.js" defer></script><script src="/assets/js/35.4656aa60.js" defer></script>
  </body>
</html>
